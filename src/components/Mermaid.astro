<div data-mermaid-definition>
  <slot />
  <div class="not-prose" data-mermaid-diagram></div>
</div>

<script>
  import { ensureNonNullable } from "~/lib/ensureNonNullable";
  import type { Theme } from "~/lib/theme";
  import { $theme } from "~/stores/theme";
  import { createIntersectionObserverAtom } from "~/lib/nanostores/createIntersectionObserverAtom";
  import { effect } from "~/lib/nanostores/effect";

  interface MermaidOptions {
    id: string;
    theme: Theme;
    element: HTMLElement;
  }

  async function renderChart({ id, theme, element }: MermaidOptions) {
    const { default: mermaid } = await import("mermaid");

    const svgContainer = ensureNonNullable(element.querySelector("[data-mermaid-diagram]"));
    const expressiveCode = ensureNonNullable(
      element.querySelector<HTMLDivElement>(".expressive-code"),
    );
    const copyButton = ensureNonNullable(
      expressiveCode.querySelector<HTMLButtonElement>(".copy button"),
    );

    const graphData = (copyButton.dataset.code ?? "")
      .replace(/\u007F/g, "\n")
      .replaceAll("\\n", "\n");

    try {
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: "loose",
        fontFamily: "inherit",
        themeCSS: "margin: 1.5rem auto 0;",
        theme: theme === "dark" ? "dark" : "default",
      });

      svgContainer.innerHTML = (await mermaid.render(id, graphData)).svg;
      expressiveCode.style.display = "none";
    } catch (error) {
      // eslint-disable-next-line no-console -- show error
      console.error("Error while rendering mermaid", error);
    }
  }

  function onLoad() {
    const definitions = document.querySelectorAll<HTMLDivElement>("[data-mermaid-definition]");

    for (const [index, element] of definitions.entries()) {
      const { $atom: $diagramIsVisible, intersectionObserver } = createIntersectionObserverAtom({
        element,
        initialValue: false,
        mapper: (entry) => entry.isIntersecting,
        observerOptions: {
          rootMargin: "0px 0px 100% 0px", // Trigger when it is on the next screen
        },
      });
      const diagramId = `mermaid-diagram-${index}`;

      effect([$diagramIsVisible, $theme], (diagramIsVisible, theme) => {
        if (!diagramIsVisible) {
          return;
        }

        // Disconnect the observer once the diagram is visible
        // $diagramIsVisible will never change after this point
        intersectionObserver?.disconnect();
        renderChart({ id: diagramId, theme, element });
      });
    }
  }

  document.addEventListener("DOMContentLoaded", onLoad);
</script>
