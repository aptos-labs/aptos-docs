---
title: "Creating and Managing Accounts"
description: "Create and manage legacy, SingleKey, and MultiKey accounts with the Kaptos Kotlin SDK"
sidebar:
  label: "Accounts"
---

Kaptos supports three account patterns you should know when building production apps:

- **Legacy Ed25519 account** (`Ed25519Account` / `Account.generate()` default)
- **SingleKey account** (`SingleKeyAccount`) using unified auth keys
- **MultiKey account** (`MultiKeyAccount`) for threshold-style signing

## Legacy account (Ed25519)

The default `Account.generate()` path creates a legacy Ed25519 account.

```kotlin
val legacy = Account.generate()

val explicitLegacy = Account.generate(
  scheme = SigningSchemeInput.Ed25519,
  legacy = true,
)
```

You can also derive a legacy account from an existing Ed25519 private key:

```kotlin
val legacyFromPrivateKey =
  Account.fromPrivateKey(
    Ed25519PrivateKey("0x...")
  )
```

## SingleKey account (Ed25519 or Secp256k1)

Use `SingleKeyAccount` when you want unified authentication and key agility.

```kotlin
val ed25519Single = SingleKeyAccount.generate(SigningSchemeInput.Ed25519)
val secp256k1Single = SingleKeyAccount.generate(SigningSchemeInput.Secp256k1)
```

You can also request a single-key account via `Account.generate(...)`:

```kotlin
val singleViaAccount = Account.generate(
  scheme = SigningSchemeInput.Ed25519,
  legacy = false,
)
```

To derive from existing private keys:

```kotlin
val ed25519SingleFromPrivateKey =
  SingleKeyAccount(
    Ed25519PrivateKey("0x...")
  )

val secp256k1SingleFromPrivateKey =
  SingleKeyAccount(
    Secp256k1PrivateKey(HexInput.fromString("0x..."))
  )
```

## MultiKey account (threshold signing)

`MultiKeyAccount` lets you define a threshold signing identity from multiple public keys.

```kotlin
val signerA = SingleKeyAccount.generate(SigningSchemeInput.Ed25519)
val signerB = SingleKeyAccount.generate(SigningSchemeInput.Secp256k1)
val signerC = SingleKeyAccount.generate(SigningSchemeInput.Ed25519)

val multiKeyAccount =
  MultiKeyAccount.fromPublicKeysAndSigners(
    publicKeys = listOf(signerA.publicKey, signerB.publicKey, signerC.publicKey),
    signaturesRequired = 2,
    signers = listOf(signerA, signerC),
  )
```

In the current API, `signers.size` must match `signaturesRequired`.

Because `MultiKeyAccount` extends `Account`, it can sign transactions like other account types:

```kotlin
val txn =
  aptos.buildSimpleTransaction(sender = multiKeyAccount.accountAddress) {
    function = "0x1::coin::transfer"
    typeArgs("0x1::aptos_coin::AptosCoin")
    args(Account.generate().accountAddress, 1_000_000UL)
  }

val pending = aptos.signAndSubmitTransaction(multiKeyAccount, txn)
```

## On-chain account creation

Generating an account only creates local credentials. The address is not usable on-chain until funded/created.

```kotlin
aptos
  .fundAccount(accountAddress = legacy.accountAddress, amount = 100_000_000L)
  .expect("Failed to fund account")
```

On testnet, you can also mint using the [faucet page](/network/faucet).
