---
title: "Building and Sending Transactions"
description: "Build, sign, and submit Aptos transactions with Kaptos using the new lean transaction DSL"
sidebar:
  label: "Building Transactions"
---

import { Aside } from '@astrojs/starlight/components';

Kaptos provides two ways to ship transactions:

- a **composable flow** (`buildSimpleTransaction` -> `sign` -> `submitTransaction.simple`)
- a **one-call flow** (`execute`) for common single-signer execution

This page uses the new lean transaction API (`typeArgs(...)`, `args(...)`) introduced in the latest SDK updates.

## Create an account

Generate credentials first, then fund the address on a test network.

```kotlin
val aptos = Aptos(AptosConfig(AptosSettings(network = Network.DEVNET)))

val alice = Account.generate()
val bob = Account.generate()

aptos.fundAccount(alice.accountAddress, 100_000_000L).expect("Failed to fund Alice")
aptos.fundAccount(bob.accountAddress, 100_000_000L).expect("Failed to fund Bob")
```

For private-key based accounts, see [Accounts](/build/sdks/community-sdks/kotlin-sdk/account).

## Build the transaction

Use `buildSimpleTransaction` with the lean entry-function builder.

```kotlin
val txn =
  aptos.buildSimpleTransaction(sender = alice.accountAddress) {
    function = "0x1::coin::transfer"
    typeArgs("0x1::aptos_coin::AptosCoin")
    args(
      bob.accountAddress,
      1_000_000UL,
    )
  }
```

`args(...)` performs automatic Kotlin -> Move coercion for common types (`Boolean`, `Int`, `ULong`, `String`, `ByteArray`, `List<T>`, `AccountAddress`, etc.), so explicit wrappers are usually optional.

If you need transaction tuning, pass options:

```kotlin
val txn =
  aptos.buildSimpleTransaction(
    sender = alice.accountAddress,
    options = InputGenerateTransactionOptions(maxGasAmount = 20_000),
  ) {
    function = "0x1::coin::transfer"
    typeArgs("0x1::aptos_coin::AptosCoin")
    args(bob.accountAddress, 1_000_000UL)
  }
```

## Sign the transaction

Use `sign` when you want explicit control over authentication before submission.

```kotlin
val senderAuthenticator = aptos.sign(signer = alice, transaction = txn)
```

## Submit the transaction

Submit the raw transaction plus sender authenticator.

```kotlin
val pendingTxn =
  aptos
    .submitTransaction.simple(
      transaction = txn,
      senderAuthenticator = senderAuthenticator,
    )
    .expect("Failed to submit transaction")
```

## Wait for execution

Wait for chain confirmation using the pending hash.

```kotlin
val executedTxn =
  aptos
    .waitForTransaction(HexInput.fromString(pendingTxn.hash))
    .expect("Transaction did not execute successfully")
```

## Execute in one call

If you do not need to inspect the intermediate transaction/authenticator objects, use `execute`:

```kotlin
val pendingTxn =
  aptos
    .execute(signer = alice) {
      function = "0x1::coin::transfer"
      typeArgs("0x1::aptos_coin::AptosCoin")
      args(bob.accountAddress, 1_000_000UL)
    }
    .expect("Failed to build/sign/submit transaction")
```

Then wait as usual:

```kotlin
val executedTxn =
  aptos
    .waitForTransaction(HexInput.fromString(pendingTxn.hash))
    .expect("Transaction did not execute successfully")
```

<Aside type="note" emoji="ℹ️">
  Backward-compatible APIs are still available (`buildTransaction.simple`, `entryFunctionData { typeArguments = ...; functionArguments = ... }`, and `signAndSubmitTransaction`). The lean API is the recommended default for new code.
</Aside>
