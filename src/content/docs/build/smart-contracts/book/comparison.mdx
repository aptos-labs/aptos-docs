---
title: "Comparison"
description: "Understand comparison operations and their semantics in Move programming language."
sidebar:
  label: "Comparison"
---

Move supports four comparison operations `<`, `>`, `<=`, and `>=`.

## Operations

| Syntax | Operation                |
| ------ | ------------------------ |
| `<`    | less than                |
| `>`    | greater than             |
| `<=`   | less than or equal to    |
| `>=`   | greater than or equal to |

### Typing

Comparison operations only work if both operands have the same type.

```move
script {
  fun example() {
    0 >= 0; // `true`
    1u128 > 2u128; // `false`
  }
}
```

If the operands have different types, there is a type checking error.

```move
script {
  fun example() {
    1u8 >= 1u128; // ERROR!
    //     ^^^^^ expected an argument of type `u8`
  }
}
```

Prior to language version 2.2, comparison operations only work with integer types. _Since language
version 2.2_, comparison operations work with all types.

| Type           | Semantics                                                                                                   |
| -------------- | ----------------------------------------------------------------------------------------------------------- |
| integer        | compare by the numerical value                                                                              |
| `bool`         | `true` being larger than `false`                                                                            |
| `address`      | compare as 256-bit unsigned integers                                                                        |
| `signer`       | compare by the `address` wrapped by the `signer`                                                            |
| `struct`       | compare by field values first, and then by the number of fields.                                            |
| `vector`       | compare by element values first, and then by the number of elements                                         |
| function value | compare in order by module address, module name, function name, argument type list, and captured value list |
| reference      | compare by the value being referenced                                                                       |

```move
module 0x42::example {
    struct S has copy, drop { f: u64, s: vector<u8> }

    fun true_example(): bool {
        let s1 = S { f: 0, s: b"" };
        let s2 = S { f: 1, s: b"" };
        // return true
        s1 < s2
    }

    fun false_example(): bool {
        let s1 = S { f: 0, s: b"abc" };
        let s2 = S { f: 0, s: b"" };
        // return false
        s1 < s2
    }
}
```

### Typing with references

When comparing [references](/build/smart-contracts/book/references), the values being referenced are compared. The type of the reference (immutable or mutable) does
not matter. This means that you can compare an immutable `&` reference with a mutable one `&mut` of
the same underlying type.

```move
script {
  fun example() {
    let i = &0u64;
    let m = &mut 1u64;

    i > m; // `false`
    m < i; // `false`
    m >= m; // `true`
    i <= i; // `true`
  }
}
```

The above is equivalent to applying an explicit freeze to each mutable reference where needed

```move
script {
  fun example() {
    let i = &0u64;
    let m = &mut 1u64;

    i > freeze(m); // `false`
    freeze(m) < i; // `false`
    m >= m; // `true`
    i <= i; // `true`
  }
}
```

But again, the underlying type must be the same.

```move
script {
  fun example() {
    let i = &0u64;
    let s = &b"";

    i > s; // ERROR!
    //   ^ expected an argument of type '&u64'
  }
}
```

## Comparing to `==` and `!=`

Comparison operations consume operands for integers but automatically borrow them for non-integer types.
This differs from the [equality `==` and inequality `!=`](/build/smart-contracts/book/equality#restrictions) operations, which always consume their operands
and mandate the [`drop` ability](/build/smart-contracts/book/abilities).

```move
module 0x42::example {
  struct Coin has store { value: u64 }
  fun invalid(c1: Coin, c2: Coin) {
    c1 <= c2 // OK!
    c1 == c2 // ERROR!
//  ^^    ^^ These resources would be destroyed!
  }
}
```
