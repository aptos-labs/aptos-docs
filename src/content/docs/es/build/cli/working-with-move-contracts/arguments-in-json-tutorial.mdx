---
title: "Tutorial de Argumentos en JSON"
description: "Aprende cómo pasar argumentos complejos a funciones Move usando formato JSON en el CLI de Aptos, incluyendo vectores, funciones de entrada, funciones de vista y funciones de script."
sidebar:
  label: "Argumentos JSON"
---

import { Aside } from '@astrojs/starlight/components';

## Información del paquete

Esta sección hace referencia al [paquete de ejemplo `CliArgs`](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/cli_args), que contiene el siguiente manifiesto:

```toml filename="move.toml"
[package]
name = "CliArgs"
version = "0.1.0"
upgrade_policy = "compatible"

[addresses]
test_account = "_"

[dependencies]
AptosFramework = { git = "https://github.com/aptos-labs/aptos-framework.git", rev = "mainnet", subdir = "aptos-framework" }
```

Aquí, el paquete se despliega bajo la dirección nombrada `test_account`.

<Aside type="note" emoji="ℹ️">
  Establece tu directorio de trabajo en [`aptos-move/move-examples/cli_args`](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/cli_args) para seguir:

  ```shellscript filename="Terminal"
  cd <directorio-padre-aptos-core>/aptos-core/aptos-move/move-examples/cli_args
  ```
</Aside>

## Desplegando el paquete

Comienza minando una dirección vanity para Ace, quien desplegará el paquete:

```shellscript filename="Terminal"
aptos key generate \
    --vanity-prefix 0xace \
    --output-file ace.key
```

<details>
  <summary>Salida</summary>

  ```shellscript filename="Terminal"
  {
    "Result": {
      "Account Address:": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
      "PublicKey Path": "ace.key.pub",
      "PrivateKey Path": "ace.key"
    }
  }
  ```

  <Aside type="note" emoji="ℹ️">
    La dirección exacta de cuenta debería variar para cada ejecución, aunque el prefijo vanity no debería.
  </Aside>
</details>

Almacena la dirección de Ace en una variable de shell, para que puedas llamarla inline más tarde:

```shellscript filename="Terminal"
# Tu dirección exacta variará
ace_addr=0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46
```

Financia la cuenta de Ace con el faucet (solo funciona en devnet):

```shellscript filename="Terminal"
aptos account fund-with-faucet --account $ace_addr
```

<details>
  <summary>Salida</summary>

  ```shellscript filename="Terminal"
  {
    "Result": "Added 100000000 Octas to account acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46"
  }
  ```
</details>

Ahora publica el paquete bajo la cuenta de Ace:

```shellscript filename="Terminal"
aptos move publish \
    --named-addresses test_account=$ace_addr \
    --private-key-file ace.key \
    --assume-yes
```

## Funciones de entrada

El único módulo en el paquete, `cli_args.move`, define un recurso `Holder` simple con campos de varios tipos de datos:

```move filename="Holder en cli_args.move"
module test_account::cli_args {
  use std::signer;
  use aptos_std::type_info::{Self, TypeInfo};
  use std::string::String;

  struct Holder has key, drop {
      u8_solo: u8,
      bytes: vector<u8>,
      utf8_string: String,
      bool_vec: vector<bool>,
      address_vec_vec: vector<vector<address>>,
      type_info_1: TypeInfo,
      type_info_2: TypeInfo,
  }
```

Una función de entrada pública con vectores multi-anidados puede usarse para establecer los campos:

```move filename="Función setter en cli_args.move"
/// Establecer valores en un `Holder` bajo `account`.
public entry fun set_vals<T1, T2>(
    account: signer,
    u8_solo: u8,
    bytes: vector<u8>,
    utf8_string: String,
    bool_vec: vector<bool>,
    address_vec_vec: vector<vector<address>>,
) acquires Holder {
    let account_addr = signer::address_of(&account);
    if (exists<Holder>(account_addr)) {
        move_from<Holder>(account_addr);
    };
    move_to(&account, Holder {
        u8_solo,
        bytes,
        utf8_string,
        bool_vec,
        address_vec_vec,
        type_info_1: type_info::type_of<T1>(),
        type_info_2: type_info::type_of<T2>(),
    });
}
```

Después de que el paquete ha sido publicado, `aptos move run` puede usarse para llamar `set_vals()`:

<Aside type="note" emoji="ℹ️">
  Para pasar vectores (incluyendo vectores anidados) como argumentos desde la línea de comandos, ¡usa sintaxis JSON escapada con comillas!
</Aside>

```shellscript filename="Ejecutando función con argumentos de vector anidado desde CLI"
aptos move run \
    --function-id $ace_addr::cli_args::set_vals \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args \
        u8:123 \
        "hex:0x1234" \
        "string:hello, world\! ♥" \
        "bool:[false, true, false, false]" \
        'address:[["0xace", "0xbee"], ["0xcad"], []]' \
    --private-key-file ace.key \
    --assume-yes
```

## Funciones de vista

Una vez que los valores en un `Holder` han sido establecidos, la función de vista `reveal()` puede usarse para verificar los primeros tres campos, y para comparar argumentos de tipo contra los últimos dos campos:

```move filename="Función de vista"
struct RevealResult has drop {
    u8_solo: u8,
    bytes: vector<u8>,
    utf8_string: String,
    bool_vec: vector<bool>,
    address_vec_vec: vector<vector<address>>,
    type_info_1_match: bool,
    type_info_2_match: bool
}

#[view]
/// Empaquetar en un `RevealResult` los primeros tres campos en el
/// `Holder` del host, así como dos banderas `bool` denotando si `T1` & `T2`
/// respectivamente coinciden con `Holder.type_info_1` & `Holder.type_info_2`,
/// luego devolver el `RevealResult`.
public fun reveal<T1, T2>(host: address): RevealResult acquires Holder {
    let holder_ref = borrow_global<Holder>(host);
    RevealResult {
        u8_solo: holder_ref.u8_solo,
        bytes: holder_ref.bytes,
        utf8_string: holder_ref.utf8_string,
        bool_vec: holder_ref.bool_vec,
        address_vec_vec: holder_ref.address_vec_vec,
        type_info_1_match:
            type_info::type_of<T1>() == holder_ref.type_info_1,
        type_info_2_match:
            type_info::type_of<T2>() == holder_ref.type_info_2
    }
}
```

Esta función de vista puede llamarse con argumentos especificados ya sea desde el CLI o desde un archivo JSON:

```shellscript filename="Argumentos via CLI"
aptos move view \
    --function-id $ace_addr::cli_args::reveal \
    --type-args \
        0x1::account::Account \
        0x1::account::Account \
    --args address:$ace_addr
```

```shellscript filename="Argumentos via archivo JSON"
aptos move view --json-file view_function_arguments.json
```

<Aside type="note" emoji="ℹ️">
  Como el momento de escribir esto, el CLI de `aptos` solo soporta argumentos de función de script para vectores de tipo `u8`, y solo hasta una profundidad de vector de 1. Por lo tanto `vector<address>` y `vector<vector<u8>>` son tipos de argumento de función de script inválidos.
</Aside>
