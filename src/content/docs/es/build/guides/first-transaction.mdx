---
title: "Tu Primera Transacción"
---

import { Aside, Steps, TabItem, Tabs } from '@astrojs/starlight/components';

Las transacciones son la forma fundamental de cambiar datos en la blockchain de Aptos. Piensa en ellas como enviar un paquete: debes especificar qué envías, a quién va dirigido y luego seguirlo hasta que se confirme la entrega. En términos de blockchain, las transacciones te permiten transferir monedas, llamar funciones de contratos inteligentes y actualizar el estado on-chain.

Este tutorial te guiará para crear y enviar tu primera transacción en la blockchain de Aptos. Aprenderás a:

1. Configura tu entorno de desarrollo
2. Crea cuentas de prueba y fúndelas
3. Construye una transacción para transferir monedas
4. Simula la transacción para estimar los costos
5. Firma y envía la transacción
6. Verifica que la transacción se haya ejecutado correctamente

<Aside type="note">
  Este tutorial se basa en conceptos de la blockchain de Aptos. Si eres nuevo en el desarrollo blockchain, no te preocupes: explicaremos conceptos clave a lo largo del camino.

  Puedes saltar al ejemplo de código completo [aquí](#full-code-sample) o continuar leyendo para un recorrido paso a paso.
</Aside>

## 1. Configurar tu Entorno

<Tabs>
  <TabItem label="TypeScript">
    Antes de crear transacciones, debemos configurar nuestro entorno de desarrollo con las herramientas y SDKs necesarios.

    <Steps>
      1. Install the TypeScript SDK

         Install the TypeScript SDK using your preferred package manager:

         <Tabs>
           <TabItem label="npm">
             ```shellscript filename="Terminal"
             npm install @aptos-labs/ts-sdk
             ```
           </TabItem>

           <TabItem label="yarn">
             ```shellscript filename="Terminal"
             yarn add @aptos-labs/ts-sdk
             ```
           </TabItem>

           <TabItem label="pnpm">
             ```shellscript filename="Terminal"
             pnpm add @aptos-labs/ts-sdk
             ```
           </TabItem>
         </Tabs>

      2. Create a project directory

         Create a new directory for your project:

         ```shellscript filename="Terminal"
         mkdir my-first-transaction
         cd my-first-transaction
         ```

      3. Create a new file

         Create a new file named `transaction.ts`:

         <Tabs>
           <TabItem label="Mac/Linux">
             ```shellscript filename="Terminal"
             touch transaction.ts
             ```
           </TabItem>

           <TabItem label="Windows">
             ```shellscript filename="Terminal"
             type nul > transaction.ts
             ```
           </TabItem>
         </Tabs>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Antes de crear transacciones, debemos configurar nuestro entorno de desarrollo con las herramientas y SDKs necesarios.

    <Steps>
      1. Instala el SDK de Python

         Instala el SDK de Python usando pip:

         ```shellscript filename="Terminal"
         pip install aptos-sdk
         ```

      2. Crea un directorio para tu proyecto

         Crea un nuevo directorio para tu proyecto:

         ```shellscript filename="Terminal"
         mkdir my-first-transaction
         cd my-first-transaction
         ```

      3. Crea un nuevo archivo

         Crea un nuevo archivo llamado `transaction.py`:

         <Tabs>
           <TabItem label="Mac/Linux">
             ```shellscript filename="Terminal"
             touch transaction.py
             ```
           </TabItem>

           <TabItem label="Windows">
             ```shellscript filename="Terminal"
             type nul > transaction.py
             ```
           </TabItem>
         </Tabs>
    </Steps>
  </TabItem>
</Tabs>

## 2. Crear Cuentas de Prueba

<Tabs>
  <TabItem label="TypeScript">
    En blockchain, todas las transacciones deben provenir de una cuenta. Crearemos dos cuentas de prueba: una para enviar monedas (Alice) y otra para recibirlas (Bob).

    <Steps>
      1. Set up the client

         Primero, necesitamos inicializar el cliente de Aptos que se conectará a la blockchain. Abre `transaction.ts` en tu editor y agrega:

         ```typescript filename="transaction.ts"
         import {
           Account,
           Aptos,
           AptosConfig,
           Network,
         } from "@aptos-labs/ts-sdk";

         async function main() {
           // Inicializa el cliente de Aptos
           const config = new AptosConfig({ network: Network.DEVNET });
           const aptos = new Aptos(config);

           console.log("Connected to Aptos devnet");

           // Más código irá aquí
         }

         main().catch(console.error);
         ```

         <Aside type="note">
           Nos estamos conectando a Aptos devnet, una red de pruebas donde puedes experimentar sin usar monedas reales. Devnet se reinicia periódicamente, así que no almacenes nada importante allí. Puedes explorar el código fuente completo del SDK de TypeScript en el [repositorio aptos-ts-sdk](https://github.com/aptos-labs/aptos-ts-sdk).
         </Aside>

      2. Generate accounts

         Agrega este código dentro de tu función `main()` para crear dos cuentas - Alice (remitente) y Bob (destinatario):

         ```typescript filename="transaction.ts"
         // Genera dos cuentas
         const alice = Account.generate();
         const bob = Account.generate();

         console.log("=== Addresses ===");
         console.log(`Alice's address: ${alice.accountAddress}`);
         console.log(`Bob's address: ${bob.accountAddress}`);
         ```

         <Aside type="note">
           Cada cuenta tiene una dirección única (como un número de cuenta bancaria) y un par de claves (como tus credenciales de inicio de sesión). La dirección se deriva de la clave pública, mientras que la clave privada se mantiene secreta y se utiliza para firmar transacciones. Para más detalles sobre cómo funcionan las cuentas en Aptos, consulta [Conceptos básicos de cuentas](/es/network/blockchain/accounts).
         </Aside>

      3. Financiar las cuentas

         Agrega este código después de generar las cuentas para obtener monedas de prueba del faucet:

         ```typescript filename="transaction.ts"
         // Financia las cuentas con APT de prueba desde el faucet de devnet
         console.log("\n=== Financiando cuentas ===");
         await aptos.fundAccount({
           accountAddress: alice.accountAddress,
           amount: 100_000_000, // 1 APT = 100,000,000 octas
         });
         console.log("Cuentas financiadas exitosamente");

         // Verifica los balances iniciales
         const aliceBalance = await aptos.getAccountAPTAmount({
           accountAddress: alice.accountAddress,
         });
         const bobBalance = await aptos.getAccountAPTAmount({
           accountAddress: bob.accountAddress,
         });

         console.log("\n=== Saldos Iniciales ===");
         console.log(`Alice: ${aliceBalance} octas`);
         console.log(`Bob: ${bobBalance} octas`);
         ```

      4. Ejecuta el código

         Probemos nuestro código hasta ahora:

         ```shellscript filename="Terminal"
         npx ts-node transaction.ts
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Addresses ===
         Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Financiando cuentas ===
         Cuentas financiadas exitosamente

         === Saldos Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas
         ```

         <Aside type="note">
           Las direcciones que veas serán diferentes a las que se muestran aquí, ya que se generan aleatoriamente cada vez.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    En blockchain, todas las transacciones deben provenir de una cuenta. Crearemos dos cuentas de prueba: una para enviar monedas (Alice) y otra para recibirlas (Bob).

    <Steps>
      1. Configura el cliente

         Primero, necesitamos inicializar el cliente de Aptos que se conectará a la blockchain. Abre `transaction.py` en tu editor y agrega:

         ```python filename="transaction.py"
         import asyncio
         from aptos_sdk.account import Account
         from aptos_sdk.async_client import FaucetClient, RestClient
         from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument, RawTransaction
         from aptos_sdk.bcs import Serializer
         import time

         # Configuración de la red
         NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
         FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

         async def main():
             # Inicializa los clientes
             rest_client = RestClient(NODE_URL)
             faucet_client = FaucetClient(FAUCET_URL, rest_client)

             print("Conectado a Aptos devnet")

             # Más código irá aquí

         if __name__ == "__main__":
             asyncio.run(main())
         ```

         <Aside type="note">
           Nos estamos conectando a Aptos devnet, una red de pruebas donde puedes experimentar sin usar monedas reales. Devnet se reinicia periódicamente, así que no almacenes nada importante allí. Puedes explorar el código fuente completo del SDK de Python en el [repositorio aptos-python-sdk](https://github.com/aptos-labs/aptos-python-sdk).
         </Aside>

      2. Generate accounts

         Agrega este código dentro de tu función `main()` para crear dos cuentas - Alice (remitente) y Bob (destinatario):

         ```python filename="transaction.py"
         # Genera dos cuentas
         alice = Account.generate()
         bob = Account.generate()

         print("=== Addresses ===")
         print(f"Alice's address: {alice.address()}")
         print(f"Bob's address: {bob.address()}")
         ```

         <Aside type="note">
           Cada cuenta tiene una dirección única (como el número de una cuenta bancaria) y un par de claves (como tus credenciales de acceso). La dirección se deriva de la clave pública, mientras que la clave privada se mantiene secreta y se utiliza para firmar transacciones. Para más detalles sobre cómo funcionan las cuentas en Aptos, consulta [Conceptos básicos de cuentas](/es/network/blockchain/accounts).
         </Aside>

      3. Fondea las cuentas

         Agrega este código después de generar las cuentas para obtener monedas de prueba del faucet:

         ```python filename="transaction.py"
         # Fondea las cuentas con APT de prueba desde el faucet de devnet
         print("\n=== Fondeando cuentas ===")
         alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
         bob_amount = 0  # Bob starts with 0 APT

         await faucet_client.fund_account(alice.address(), alice_amount)
         print("Cuenta fondeada exitosamente")

         # Verifica los balances iniciales
         alice_balance = await rest_client.account_balance(alice.address())
         bob_balance = await rest_client.account_balance(bob.address())

         print("\n=== Initial Balances ===")
         print(f"Alice: {alice_balance} octas")
         print(f"Bob: {bob_balance} octas")
         ```

      4. Run the code

         Probemos nuestro código hasta ahora:

         ```shellscript filename="Terminal"
         python transaction.py
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Addresses ===
         Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Fondeando cuentas ===
         Cuentas fondeadas exitosamente

         === Balances iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas
         ```

         <Aside type="note">
           Las direcciones que veas serán diferentes a las que se muestran aquí, ya que se generan aleatoriamente cada vez.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 3. Crear una Transacción

<Tabs>
  <TabItem label="TypeScript">
    Ahora que tenemos cuentas financiadas, creemos una transacción para transferir monedas de Alice a Bob. Es como completar un formulario indicando qué quieres enviar y a quién.

    <Steps>
      1. Entender la estructura de una transacción

      Una transacción en Aptos tiene varios componentes clave:

      1. **Remitente**: La cuenta que inicia la transacción (Alice)
      2. **Función**: La función on-chain a invocar (en este caso, una transferencia de monedas)
      3. **Argumentos**: Datos que requiere la función (dirección del receptor y monto)
      4. **Parámetros de gas**: Máximo de gas y precio por unidad de gas
      5. **Tiempo de expiración**: Momento a partir del cual la transacción deja de ser válida si no se ejecuta
      6. **Número de secuencia**: Contador que previene ataques de repetición

      <Aside type="note">
        Todos los datos en transacciones de Aptos se serializan usando Binary Canonical Serialization (BCS), un formato compacto y determinista diseñado para blockchain. El SDK gestiona esta serialización por ti.

        BCS asegura que los datos de la transacción se codifiquen de forma consistente entre plataformas e idiomas, lo cual es crítico en una blockchain donde la misma transacción puede ser procesada por nodos con distintas implementaciones.
      </Aside>

      2. Construir la transacción

         Agreguemos código para construir una transacción que transfiera 1000 octas de Alice a Bob:

         Agrega este código a tu función `main()`:

         ```typescript filename="transaction.ts"
         // 1. Construir la transacción
         console.log("\n=== 1. Construyendo la transacción ===");
         const transaction = await aptos.transaction.build.simple({
           sender: alice.accountAddress,
           data: {
             function: "0x1::aptos_account::transfer",
             functionArguments: [bob.accountAddress, 1000], // Transferir 1000 octas
           },
         });
         console.log("Transacción construida exitosamente");

         // Accede a los detalles de la transacción desde la transacción sin procesar
         const rawTxn = transaction.rawTransaction;
         console.log(`Sender: ${rawTxn.sender}`);
         console.log(`Sequence Number: ${rawTxn.sequence_number}`);
         console.log(`Max Gas Amount: ${rawTxn.max_gas_amount}`);
         console.log(`Gas Unit Price: ${rawTxn.gas_unit_price}`);
         console.log(`Expiration Timestamp: ${new Date(Number(rawTxn.expiration_timestamp_secs) * 1000).toISOString()}`);
         ```

         <Aside type="note">
           La función `0x1::aptos_account::transfer` es una función incorporada en el framework de Aptos que transfiere monedas entre cuentas. El prefijo `0x1` indica que es parte del framework core. Internamente, esta función llama al [código fuente del módulo Coin](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) para realizar la transferencia.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Ahora que tenemos cuentas financiadas, creemos una transacción para transferir monedas de Alice a Bob. Es como completar un formulario indicando qué quieres enviar y a quién.

    <Steps>
      1. Understand transaction structure

         Una transacción en Aptos tiene varios componentes clave:

         1. **Remitente**: La cuenta que inicia la transacción (Alice)
         2. **Función**: La función on-chain a invocar (en este caso, una transferencia de monedas)
         3. **Argumentos**: Datos que requiere la función (dirección del receptor y monto)
         4. **Parámetros de gas**: Máximo de gas y precio por unidad de gas
         5. **Tiempo de expiración**: Momento a partir del cual la transacción deja de ser válida si no se ejecuta
         6. **Número de secuencia**: Contador que previene ataques de repetición

         <Aside type="note">
           Todos los datos en transacciones de Aptos se serializan usando Binary Canonical Serialization (BCS), un formato compacto y determinista diseñado para blockchain. El SDK gestiona esta serialización por ti.

           BCS asegura que los datos de la transacción se codifiquen de forma consistente entre plataformas e idiomas, lo cual es crítico en una blockchain donde la misma transacción puede ser procesada por nodos con distintas implementaciones.
         </Aside>

      2. Construir la transacción

      Agrega el siguiente código a tu función `main()` para construir una transacción que transfiera 1000 octas de Alice a Bob:

      ```python filename="transaction.py"
      # 1. Construir la transacción
      print("\n=== 1. Construyendo la transacción ===")

      # Crear el payload de la función de entrada
      # Esto especifica qué función llamar y con qué argumentos
      entry_function = EntryFunction.natural(
          "0x1::aptos_account",  # Dirección y nombre del módulo
          "transfer",            # Nombre de la función
          [],                    # Argumentos de tipo (vacío para esta función)
          [
              # Argumentos de la función con su tipo de serialización
              TransactionArgument(bob.address(), Serializer.struct),  # Dirección del destinatario
              TransactionArgument(1000, Serializer.u64),              # Monto a transferir (1000 octas)
      )

      # Obtener el ID de la cadena para la transacción
      chain_id = await rest_client.chain_id()

      # Obtener el número de secuencia actual del remitente
      account_data = await rest_client.account(alice.address())
      sequence_number = int(account_data["sequence_number"])

      # Crear la transacción cruda con todos los campos requeridos
      raw_transaction = RawTransaction(
          sender=alice.address(),                                    # Dirección del remitente
          sequence_number=sequence_number,                           # Número de secuencia para prevenir ataques de repetición
          payload=TransactionPayload(entry_function),                # La función a llamar
          max_gas_amount=2000,                                       # Unidades máximas de gas a usar
          gas_unit_price=100,                                        # Precio por unidad de gas en octas
          expiration_timestamps_secs=int(time.time()) + 600,         # Expira en 10 minutos
          chain_id=chain_id,                                         # ID de la cadena para asegurar la red correcta
      )

      print("Transacción construida exitosamente")
      print(f"Sender: {raw_transaction.sender}")
      print(f"Sequence Number: {raw_transaction.sequence_number}")
      print(f"Max Gas Amount: {raw_transaction.max_gas_amount}")
      print(f"Gas Unit Price: {raw_transaction.gas_unit_price}")
      print(f"Expiration Timestamp: {time.ctime(raw_transaction.expiration_timestamps_secs)}")
      ```

      <Aside type="note">
        La función `0x1::aptos_account::transfer` es una función incorporada en el framework de Aptos que transfiere monedas entre cuentas. El prefijo `0x1` indica que forma parte del framework central. Detrás de escena, esta función llama al [código fuente del módulo Coin Move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) para realizar la transferencia real.

        El SDK de Python utiliza varios componentes clave para construir transacciones:

        - `EntryFunction.natural()` crea una referencia a una función Move invocable
        - `TransactionArgument` junto con los tipos de `Serializer` asegura la serialización BCS adecuada
        - `TransactionPayload` envuelve la función de entrada para incluirla en la transacción
        - `RawTransaction` combina todos los parámetros de la transacción en una transacción completa

        Este enfoque por capas te da un control detallado sobre la construcción de la transacción.
      </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 4. Simular la Transacción

<Tabs>
  <TabItem label="TypeScript">
    Antes de enviar una transacción, es recomendable simularla para estimar el costo de gas. Es como verificar costos de envío antes de mandar un paquete.

    <Steps>
      1. Simula la transacción

         Agrega este código después de construir la transacción:

         ```typescript filename="transaction.ts"
         // 2. Simula la transacción
         console.log("\n=== 2. Simulando la transacción ===");
         const [simulationResult] = await aptos.transaction.simulate.simple({
           signerPublicKey: alice.publicKey,
           transaction,
         });

         const gasUsed = parseInt(simulationResult.gas_used);
         const gasUnitPrice = parseInt(simulationResult.gas_unit_price);
         console.log(`Unidades de gas estimadas: ${gasUsed}`);
         console.log(`Costo estimado de gas: ${gasUsed * gasUnitPrice} octas`);
         console.log(`La transacción ${simulationResult.success ? "tendría éxito" : "fallaría"}`);
         ```

         <Aside type="note">
           El gas es la tarifa computacional pagada para procesar transacciones en la blockchain. El costo total se calcula como `gas_used × gas_unit_price`. Durante la simulación, la blockchain ejecuta la transacción en un entorno temporal para estimar estos costos sin hacer cambios permanentes al estado. Esto ayuda a evitar transacciones fallidas por gas insuficiente.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Antes de enviar una transacción, es recomendable simularla para estimar el costo de gas. Es como verificar costos de envío antes de mandar un paquete.

    <Steps>
      1. Simula la transacción

         Agrega este código después de construir la transacción:

         ```python filename="transaction.py"
         # 2. Simula la transacción
         print("\n=== 2. Simulando la transacción ===")

         # Crea una transacción BCS para la simulación
         # Esto no envía realmente la transacción a la blockchain
         simulation_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(entry_function))

         # Simula la transacción para estimar los costos de gas y verificar errores
         simulation_result = await rest_client.simulate_transaction(simulation_transaction, alice)

         # Extrae y muestra los resultados de la simulación
         gas_used = int(simulation_result[0]['gas_used'])
         gas_unit_price = int(simulation_result[0]['gas_unit_price'])
         success = simulation_result[0]['success']

         print(f"Estimated gas units: {gas_used}")
         print(f"Estimated gas cost: {gas_used * gas_unit_price} octas")
         print(f"Transaction would {'succeed' if success else 'fail'}")
         ```

         <Aside type="note">
           El gas es la tarifa computacional pagada para procesar transacciones en la blockchain. El costo total se calcula como `gas_used × gas_unit_price`. Durante la simulación, la blockchain ejecuta la transacción en un entorno temporal para estimar estos costos sin hacer cambios permanentes al estado. Esto ayuda a evitar transacciones fallidas por gas insuficiente.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 5. Firmar y Enviar la Transacción

<Tabs>
  <TabItem label="TypeScript">
    Ahora que hemos construido y simulado la transacción, debemos firmarla con la clave privada de Alice y enviarla a la blockchain.

    <Steps>
      1. Firmar la transacción

         Firmar demuestra que Alice autorizó esta transacción:

      Agrega este código después de simular la transacción:

      ```typescript filename="transaction.ts"
      // 3. Firmar la transacción
      console.log("\n=== 3. Firmando la transacción ===");
      const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
      });
      console.log("Transaction signed successfully");
      ```

      <Aside type="note">
        Las firmas digitales funcionan como un sello o firma personal en el mundo físico. Prueban que la transacción fue autorizada por el propietario de la cuenta (quien tiene la clave privada) y que no ha sido manipulada.
      </Aside>

      2. Enviar la transacción

         Agrega este código después de firmar la transacción para enviar la transacción firmada a la blockchain:

      ```typescript filename="transaction.ts"
      // 4. Enviar la transacción
      console.log("\n=== 4. Submitting the transaction ===");
      const pendingTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
      });
      console.log(`Transacción enviada con hash: ${pendingTransaction.hash}`);
      ```

      <Aside type="note">
        El hash de la transacción es un identificador único, similar a un número de guía de un paquete. Al enviar una transacción, la blockchain de Aptos realiza varias validaciones, incluyendo verificar la firma y asegurar que el número de secuencia no se haya usado antes (previniendo ataques de repetición). Puedes usar el hash para revisar el estado de tu transacción en el [Aptos Explorer](https://explorer.aptoslabs.com/) o vía la [REST API](/es/build/apis/fullnode-rest-api).
      </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Ahora que hemos construido y simulado la transacción, debemos firmarla con la clave privada de Alice y enviarla a la blockchain.

    <Steps>
      1. Firmar la transacción

         Firmar demuestra que Alice autorizó esta transacción:

      Agrega este código después de simular la transacción:

      ```python filename="transaction.py"
      # 3. Firmar la transacción
      print("\n=== 3. Firmando la transacción ===")

      # Sign the raw transaction with the sender's private key
      # This creates a cryptographic signature that proves the sender authorized this transaction
      signed_transaction = await rest_client.create_bcs_signed_transaction(
          alice,                           # Account with the private key
          TransactionPayload(entry_function),  # The payload from our transaction
          sequence_number=sequence_number  # Use the same sequence number as before
      )

      print("Transaction signed successfully")
      # We can't easily extract the signature from the signed transaction object,
      # but we can confirm it was created
      ```

      <Aside type="note">
        Digital signatures work like a personal seal or signature in the physical world. They prove that the transaction was authorized by the account owner (who has the private key) and haven't been tampered with.
      </Aside>

      2. Enviar la transacción

         Agrega este código después de firmar la transacción para enviar la transacción firmada a la blockchain:

      ```python filename="transaction.py"
      # 4. Submit the transaction
      print("\n=== 4. Submitting the transaction ===")

      # Submit the signed transaction to the blockchain
      # This broadcasts the transaction to the network for processing
      tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)

      print(f"Transaction submitted with hash: {tx_hash}")
      ```

      <Aside type="note">
        El hash de la transacción es un identificador único, similar a un número de guía de un paquete. Al enviar una transacción, la blockchain de Aptos realiza varias validaciones, incluyendo verificar la firma y asegurar que el número de secuencia no se haya usado antes (previniendo ataques de repetición). Puedes usar el hash para revisar el estado de tu transacción en el [Aptos Explorer](https://explorer.aptoslabs.com/) o vía la [REST API](/es/build/apis/fullnode-rest-api).
      </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 6. Esperar la Confirmación

<Tabs>
  <TabItem label="TypeScript">
    Después de enviar una transacción, debemos esperar a que sea procesada por la blockchain. Es como esperar a que llegue un paquete.

    <Steps>
      1. Esperar la finalización de la transacción

         Agrega este código después de enviar la transacción:

      ```typescript filename="transaction.ts"
      // 5. Wait for the transaction to complete
      console.log("\n=== 5. Waiting for transaction completion ===");
      const txnResult = await aptos.waitForTransaction({
        transactionHash: pendingTransaction.hash,
      });
      console.log(`Transaction completed with status: ${txnResult.success ? "SUCCESS" : "FAILURE"}`);

      // If you want to see more details about the transaction:
      console.log(`VM Status: ${txnResult.vm_status}`);
      console.log(`Gas used: ${txnResult.gas_used}`);
      ```

      2. Verificar los resultados

         Agrega este código después de esperar la transacción para verificar los saldos y confirmar que la transferencia funcionó:

      ```typescript filename="transaction.ts"
      // Check final balances
      const aliceFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Final Balances ===");
      console.log(`Alice: ${aliceFinalBalance} octas (spent ${aliceBalance - aliceFinalBalance} octas on transfer and gas)`);
      console.log(`Bob: ${bobFinalBalance} octas (received 1000 octas)`);
      ```

      3. Run the complete code

         ```shellscript filename="Terminal"
         npx ts-node transaction.ts
         ```

         Deberías ver una salida similar a:

         ```
         Connected to Aptos devnet
         === Addresses ===
         Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Funding accounts ===
         Accounts funded successfully

         === Initial Balances ===
         Alice: 100000000 octas
         Bob: 0 octas

         === 1. Building the transaction ===
         Transaction built successfully
         Sender: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Sequence Number: 0
         Max Gas Amount: 20000
         Gas Unit Price: 100
         Expiration Timestamp: 2025-03-05T22:59:21.000Z

         === 2. Simulating the transaction ===
         Estimated gas units: 146
         Estimated gas cost: 14600 octas
         Transaction would succeed

         === 3. Signing the transaction ===
         Transaction signed successfully

         === 4. Submitting the transaction ===
         Transaction submitted with hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

         === 5. Waiting for transaction completion ===
         Transaction completed with status: SUCCESS
         VM Status: Executed successfully
         Gas used: 146

         === Final Balances ===
         Alice: 99984400 octas (spent 15600 octas on transfer and gas)
         Bob: 1000 octas (received 1000 octas)
         ```

         <Aside type="note">
           Nota que el saldo de Alice disminuyó en más de 1000 octas. La cantidad extra es la tarifa de gas pagada para procesar la transacción. Tras bambalinas, al verificar saldos, el SDK consulta el recurso CoinStore para AptosCoin (`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`) y lee el valor almacenado actual. Esto demuestra cómo el SDK abstrae interacciones complejas de blockchain en simples llamadas de función.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Después de enviar una transacción, debemos esperar a que sea procesada por la blockchain. Es como esperar a que llegue un paquete.

    <Steps>
      1. Wait for transaction completion

         Agrega este código después de enviar la transacción:

         ```python filename="transaction.py"
         # 5. Wait for the transaction to complete
         print("\n=== 5. Waiting for transaction completion ===")

         # Wait for the transaction to be processed by the blockchain
         # Esto consulta la blockchain hasta que la transacción quede confirmada
         await rest_client.wait_for_transaction(tx_hash)

         # Get the transaction details to check its status
         transaction_details = await rest_client.transaction_by_hash(tx_hash)
         success = transaction_details["success"]
         vm_status = transaction_details["vm_status"]
         gas_used = transaction_details["gas_used"]

         print(f"Transaction completed with status: {'SUCCESS' if success else 'FAILURE'}")
         print(f"VM Status: {vm_status}")
         print(f"Gas used: {gas_used}")
         ```

      2. Verify the results

         Add this code after waiting for the transaction to check the balances and confirm the transfer worked:

         ```python filename="transaction.py"
         # Check final balances
         alice_final_balance = await rest_client.account_balance(alice.address())
         bob_final_balance = await rest_client.account_balance(bob.address())

         print("\n=== Final Balances ===")
         print(f"Alice: {alice_final_balance} octas (spent {alice_balance - alice_final_balance} octas on transfer and gas)")
         print(f"Bob: {bob_final_balance} octas (received 1000 octas)")
         ```

      3. Run the complete code

         ```shellscript filename="Terminal"
         python transaction.py
         ```

         Deberías ver una salida similar a:

         ```
         Connected to Aptos devnet
         === Addresses ===
         Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Funding accounts ===
         Accounts funded successfully

         === Initial Balances ===
         Alice: 100000000 octas
         Bob: 0 octas

         === 1. Building the transaction ===
         Transaction built successfully
         Sender: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Sequence Number: 0
         Max Gas Amount: 2000
         Gas Unit Price: 100
         Expiration Timestamp: Wed Mar 05 22:59:21 2025

         === 2. Simulating the transaction ===
         Estimated gas units: 146
         Estimated gas cost: 14600 octas
         Transaction would succeed

         === 3. Signing the transaction ===
         Transaction signed successfully

         === 4. Submitting the transaction ===
         === 3. Signing the transaction ===
         Transaction signed successfully

         === 4. Submitting the transaction ===
         Transaction submitted with hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

         === 5. Waiting for transaction completion ===
         Transaction completed with status: SUCCESS
         VM Status: Executed successfully
         Gas used: 146

         === Final Balances ===
         Alice: 99984400 octas (spent 15600 octas on transfer and gas)
         Bob: 1000 octas (received 1000 octas)
         ```

         <Aside type="note">
           Nota que el saldo de Alice disminuyó en más de 1000 octas. La cantidad extra es la tarifa de gas pagada para procesar la transacción. Tras bambalinas, al verificar saldos, el SDK consulta el recurso CoinStore para AptosCoin (`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`) y lee el valor almacenado actual.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 7. (Opcional) Explora tu Transacción On-Chain

Ahora que ejecutaste una transacción con éxito, puedes explorarla en el Aptos Explorer. Esto te ayudará a entender cómo se registran las transacciones en la blockchain y qué información es pública.

<Steps>
  1. Copia el hash de tu transacción

     De la salida de tu terminal, copia el hash de la transacción que se imprimió después del envío. Se ve algo así:

     ```
     Transaction submitted with hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc
     ```

  2. Abre el Aptos Explorer

     Ve al [Aptos Explorer](https://explorer.aptoslabs.com/?network=devnet).

  3. Asegúrate de estar en la red Devnet

     Busca "Devnet" en la esquina superior derecha, o cambia de red haciendo clic en el desplegable y seleccionando Devnet.

     ![Switching to Devnet network in Aptos Explorer](~/images/screenshots/explorer_devnet.png)

  4. Busca tu transacción

     Pega el hash de tu transacción en la barra de búsqueda en el centro de la página.

     <Aside type="caution">
       ¡No presiones Enter! Hay un bug conocido donde buscar con Enter no funciona.
     </Aside>

  5. Ver los detalles de la transacción

     Espera a que aparezcan los resultados, luego haz clic en el hash de la transacción para ver sus detalles.

     Deberías ver información sobre tu transacción, incluyendo:

     - Estado (debería ser "Success")
     - Marca de tiempo
     - Gas usado
     - Direcciones de remitente y destinatario
     - Monto transferido

  6. Explora más

     Desde la página de detalles de la transacción, puedes:

     - Hacer clic en las direcciones del remitente o destinatario para ver detalles de sus cuentas
     - Ver los cambios exactos hechos al estado de la blockchain
     - Ver el payload y argumentos de la transacción

     <Aside type="note">
       El Explorer es una herramienta poderosa para depurar transacciones y entender la actividad en la blockchain. Los desarrolladores lo usan frecuentemente para verificar que sus transacciones se ejecutaron como se esperaba e investigar problemas.
     </Aside>
</Steps>

## 8. Próximos Pasos

¡Felicidades! Has creado y ejecutado tu primera transacción en la blockchain de Aptos. Aquí tienes algunas sugerencias para explorar a continuación:

**Aprende sobre transacciones más complejas**:

- [Firmas Multi-Agente](/es/build/sdks/ts-sdk/building-transactions/multi-agent-transactions) - Transacciones que requieren múltiples firmantes
- [Patrocinar Transacciones](/es/build/sdks/ts-sdk/building-transactions/sponsoring-transactions) - Hacer que otra cuenta pague las tarifas de gas
- [Agrupar Transacciones](/es/build/sdks/ts-sdk/building-transactions/batching-transactions) - Enviar múltiples transacciones eficientemente

<Aside type="note">
  The above links are for the Typescript SDK but the principles are the same if you are using Python or Rust.
</Aside>

**Explora contratos inteligentes o conceptos básicos de cuentas**:

- [Tu Primer Módulo Move](/es/build/guides/first-move-module) - Crea tu propio contrato inteligente
- [Conceptos Básicos de Cuentas](/es/network/blockchain/accounts)

[¡Únete al Discord de Aptos](https://discord.gg/aptoslabs) y comparte lo que estás construyendo!

## Full Code Sample

Las muestras de código completas a continuación combinan todos los fragmentos que hemos cubierto en este tutorial:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript filename="transaction.ts"
    import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

    async function main() {
      // Initialize the Aptos client
      const config = new AptosConfig({ network: Network.DEVNET });
      const aptos = new Aptos(config);

      console.log("Connected to Aptos devnet");

      // More code will go here
      // Generate two accounts
      const alice = Account.generate();
      const bob = Account.generate();

      console.log("=== Addresses ===");
      console.log(`Alice's address: ${alice.accountAddress}`);
      console.log(`Bob's address: ${bob.accountAddress}`);

      // Fund the accounts with test APT from the devnet faucet
      console.log("\n=== Funding accounts ===");
      await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 100_000_000, // 1 APT = 100,000,000 octas
      });
      await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 0, // Bob starts with 0 APT
      });
      console.log("Accounts funded successfully");

      // Check initial balances
      const aliceBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Initial Balances ===");
      console.log(`Alice: ${aliceBalance} octas`);
      console.log(`Bob: ${bobBalance} octas`);

      // 1. Build the transaction
      console.log("\n=== 1. Building the transaction ===");
      const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        data: {
          function: "0x1::aptos_account::transfer",
          functionArguments: [bob.accountAddress, 1000], // Transfer 1000 octas
        },
      });
      console.log("Transaction built successfully");
      // Use type assertion to bypass TypeScript's type checking
      const txnAny = transaction as any;
      console.log(`Sender: ${alice.accountAddress}`); // Use the known sender address
      console.log(`Sequence Number: ${txnAny.sequenceNumber || "N/A"}`);
      console.log(`Max Gas Amount: ${txnAny.maxGasAmount || "N/A"}`);
      console.log(`Gas Unit Price: ${txnAny.gasUnitPrice || "N/A"}`);
      console.log(
        `Expiration Timestamp: ${new Date(
          Number(txnAny.expirationTimestampSecs || 0) * 1000
        ).toISOString()}`
      );

      // 2. Simulate the transaction
      console.log("\n=== 2. Simulating the transaction ===");
      const [simulationResult] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        transaction,
      });

      console.log(`Estimated gas units: ${simulationResult.gas_used}`);
      console.log(
        `Estimated gas cost: ${
          Number(simulationResult.gas_used) * Number(simulationResult.gas_unit_price)
        } octas`
      );
      console.log(
        `Transaction would ${simulationResult.success ? "succeed" : "fail"}`
      );

      // 3. Sign the transaction
      console.log("\n=== 3. Signing the transaction ===");
      const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
      });
      console.log("Transaction signed successfully");
      // Use type assertion to bypass TypeScript's type checking
      const authAny = senderAuthenticator as any;
      const signatureStr = typeof authAny.signature === 'string'
        ? authAny.signature
        : JSON.stringify(authAny.signature || '');
      console.log(`Signature: ${signatureStr.slice(0, 20)}...`);

      // 4. Submit the transaction
      console.log("\n=== 4. Submitting the transaction ===");
      const pendingTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
      });
      console.log(`Transaction submitted with hash: ${pendingTransaction.hash}`);

      // 5. Wait for the transaction to complete
      console.log("\n=== 5. Waiting for transaction completion ===");
      const txnResult = await aptos.waitForTransaction({
        transactionHash: pendingTransaction.hash,
      });
      console.log(
        `Transaction completed with status: ${
          txnResult.success ? "SUCCESS" : "FAILURE"
        }`
      );

      // If you want to see more details about the transaction:
      console.log(`VM Status: ${txnResult.vm_status}`);
      console.log(`Gas used: ${txnResult.gas_used}`);

      // Check final balances
      const aliceFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Final Balances ===");
      console.log(
        `Alice: ${aliceFinalBalance} octas (spent ${
          aliceBalance - aliceFinalBalance
        } octas on transfer and gas)`
      );
      console.log(`Bob: ${bobFinalBalance} octas (received 1000 octas)`);
    }

    main().catch(console.error);
    ```
  </TabItem>

  <TabItem label="Python">
    ```python filename="transaction.py"
    import asyncio
    from aptos_sdk.account import Account
    from aptos_sdk.async_client import FaucetClient, RestClient
    from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument, RawTransaction
    from aptos_sdk.bcs import Serializer
    import time

    # Network configuration
    NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
    FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

    async def main():
        # Initialize the clients
        rest_client = RestClient(NODE_URL)
        faucet_client = FaucetClient(FAUCET_URL, rest_client)

        print("Connected to Aptos devnet")

        # Generate two accounts
        alice = Account.generate()
        bob = Account.generate()

        print("=== Addresses ===")
        print(f"Alice's address: {alice.address()}")
        print(f"Bob's address: {bob.address()}")
            # More code will go here
            # Fund the accounts with test APT from the devnet faucet
        print("\n=== Funding accounts ===")
        alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
        bob_amount = 0  # Bob starts with 0 APT

        await faucet_client.fund_account(alice.address(), alice_amount)
        await faucet_client.fund_account(bob.address(), bob_amount)
        print("Accounts funded successfully")

        # Check initial balances
        alice_balance = await rest_client.account_balance(alice.address())
        bob_balance = await rest_client.account_balance(bob.address())

        print("\n=== Initial Balances ===")
        print(f"Alice: {alice_balance} octas")
        print(f"Bob: {bob_balance} octas")

        # 1. Build the transaction
        print("\n=== 1. Building the transaction ===")

        # Create the entry function payload
        # This specifies which function to call and with what arguments
        entry_function = EntryFunction.natural(
            "0x1::aptos_account",  # Module address and name
            "transfer",            # Function name
            [],                    # Type arguments (empty for this function)
            [
                # Function arguments with their serialization type
                TransactionArgument(bob.address(), Serializer.struct),  # Recipient address
                TransactionArgument(1000, Serializer.u64),              # Amount to transfer (1000 octas)
            ],
        )

        # Get the chain ID for the transaction
        chain_id = await rest_client.chain_id()

        # Get the sender's current sequence number
        account_data = await rest_client.account(alice.address())
        sequence_number = int(account_data["sequence_number"])

        # Create the raw transaction with all required fields
        raw_transaction = RawTransaction(
            sender=alice.address(),                                    # Sender's address
            sequence_number=sequence_number,                           # Sequence number to prevent replay attacks
            payload=TransactionPayload(entry_function),                # The function to call
            max_gas_amount=2000,                                       # Maximum gas units to use
            gas_unit_price=100,                                        # Price per gas unit in octas
            expiration_timestamps_secs=int(time.time()) + 600,         # Expires in 10 minutes
            chain_id=chain_id,                                         # Chain ID to ensure correct network
        )

        print("Transaction built successfully")
        print(f"Sender: {raw_transaction.sender}")
        print(f"Sequence Number: {raw_transaction.sequence_number}")
        print(f"Max Gas Amount: {raw_transaction.max_gas_amount}")
        print(f"Gas Unit Price: {raw_transaction.gas_unit_price}")
        print(f"Expiration Timestamp: {time.ctime(raw_transaction.expiration_timestamps_secs)}")

        # 2. Simulate the transaction
        print("\n=== 2. Simulating the transaction ===")

        # Create a BCS transaction for simulation
        # This doesn't actually submit the transaction to the blockchain
        simulation_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(entry_function))

        # Simulate the transaction to estimate gas costs and check for errors
        simulation_result = await rest_client.simulate_transaction(simulation_transaction, alice)

        # Extract and display the simulation results
        gas_used = int(simulation_result[0]['gas_used'])
        gas_unit_price = int(simulation_result[0]['gas_unit_price'])
        success = simulation_result[0]['success']

        print(f"Estimated gas units: {gas_used}")
        print(f"Estimated gas cost: {gas_used * gas_unit_price} octas")
        print(f"Transaction would {'succeed' if success else 'fail'}")

        # 3. Sign the transaction
        print("\n=== 3. Signing the transaction ===")

        # Sign the raw transaction with the sender's private key
        # This creates a cryptographic signature that proves the sender authorized this transaction
        signed_transaction = await rest_client.create_bcs_signed_transaction(
            alice,                                  # Account with the private key
            TransactionPayload(entry_function),     # The payload from our transaction
            sequence_number=sequence_number         # Use the same sequence number as before
        )

        print("Transaction signed successfully")
        # We can't easily extract the signature from the signed transaction object,
        # but we can confirm it was created

        # 4. Submit the transaction
        print("\n=== 4. Submitting the transaction ===")

        # Submit the signed transaction to the blockchain
        # This broadcasts the transaction to the network for processing
        tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)

        print(f"Transaction submitted with hash: {tx_hash}")

        # 5. Wait for the transaction to complete
        print("\n=== 5. Waiting for transaction completion ===")

        # Wait for the transaction to be processed by the blockchain
        # This polls the blockchain until the transaction is confirmed
        await rest_client.wait_for_transaction(tx_hash)

        # Get the transaction details to check its status
        transaction_details = await rest_client.transaction_by_hash(tx_hash)
        success = transaction_details["success"]
        vm_status = transaction_details["vm_status"]
        gas_used = transaction_details["gas_used"]

        print(f"Transaction completed with status: {'SUCCESS' if success else 'FAILURE'}")
        print(f"VM Status: {vm_status}")
        print(f"Gas used: {gas_used}")

        # Check final balances
        alice_final_balance = await rest_client.account_balance(alice.address())
        bob_final_balance = await rest_client.account_balance(bob.address())

        print("\n=== Final Balances ===")
        print(f"Alice: {alice_final_balance} octas (spent {alice_balance - alice_final_balance} octas on transfer and gas)")
        print(f"Bob: {bob_final_balance} octas (received 1000 octas)")
    if __name__ == "__main__":
        asyncio.run(main())
    ```
  </TabItem>
</Tabs>
