---
title: "Tu Primera Transacción"
description: "Crea y envía tu primera transacción en la blockchain de Aptos - transfiere monedas entre cuentas con ejemplos en TypeScript y Python."
sidebar:
  label: "Primera Transacción"
---

import { Aside, Steps, TabItem, Tabs } from '@astrojs/starlight/components';

Las transacciones son la forma fundamental de cambiar datos en la blockchain de Aptos. Piensa en ellas como enviar un paquete: necesitas especificar qué estás enviando, a quién va dirigido, y luego rastrearlo hasta que se confirme la entrega. En términos de blockchain, las transacciones te permiten transferir monedas, llamar funciones de contratos inteligentes y actualizar el estado en cadena.

Este tutorial te guiará a través de la creación y envío de tu primera transacción en la blockchain de Aptos. Aprenderás cómo:

1. Configurar tu entorno de desarrollo
2. Crear cuentas de prueba y financiarlas
3. Construir una transacción para transferir monedas
4. Simular la transacción para estimar costos
5. Firmar y enviar la transacción
6. Verificar que la transacción se ejecutó exitosamente

<Aside type="note">
  Este tutorial se basa en conceptos de la blockchain de Aptos. Si eres nuevo en el desarrollo blockchain, no te preocupes - explicaremos conceptos clave en el camino.

  Puedes saltar a la muestra completa de código [aquí](#full-code-sample) o continuar leyendo para un tutorial paso a paso.
</Aside>

## 1. Configuración de Tu Entorno

<Tabs>
  <TabItem label="TypeScript">
    Antes de poder crear transacciones, necesitamos configurar nuestro entorno de desarrollo con las herramientas y SDKs necesarias.

    <Steps>
      1. Instalar el SDK de TypeScript

         Instala el SDK de TypeScript usando tu gestor de paquetes preferido:

         <Tabs>
           <TabItem label="npm">
             ```shellscript filename="Terminal"
             npm install @aptos-labs/ts-sdk
             ```
           </TabItem>

           <TabItem label="yarn">
             ```shellscript filename="Terminal"
             yarn add @aptos-labs/ts-sdk
             ```
           </TabItem>

           <TabItem label="pnpm">
             ```shellscript filename="Terminal"
             pnpm add @aptos-labs/ts-sdk
             ```
           </TabItem>
         </Tabs>

      2. Crear un directorio de proyecto

         Crea un nuevo directorio para tu proyecto:

         ```shellscript filename="Terminal"
         mkdir mi-primera-transaccion
         cd mi-primera-transaccion
         ```

      3. Crear un nuevo archivo

         Crea un nuevo archivo llamado `transaction.ts`:

         <Tabs>
           <TabItem label="Mac/Linux">
             ```shellscript filename="Terminal"
             touch transaction.ts
             ```
           </TabItem>

           <TabItem label="Windows">
             ```shellscript filename="Terminal"
             type nul > transaction.ts
             ```
           </TabItem>
         </Tabs>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Antes de poder crear transacciones, necesitamos configurar nuestro entorno de desarrollo con las herramientas y SDKs necesarias.

    <Steps>
      1. Instalar el SDK de Python

         Instala el SDK de Python usando pip:

         ```shellscript filename="Terminal"
         pip install aptos-sdk
         ```

      2. Crear un directorio de proyecto

         Crea un nuevo directorio para tu proyecto:

         ```shellscript filename="Terminal"
         mkdir mi-primera-transaccion
         cd mi-primera-transaccion
         ```

      3. Crear un nuevo archivo

         Crea un nuevo archivo llamado `transaction.py`:

         <Tabs>
           <TabItem label="Mac/Linux">
             ```shellscript filename="Terminal"
             touch transaction.py
             ```
           </TabItem>

           <TabItem label="Windows">
             ```shellscript filename="Terminal"
             type nul > transaction.py
             ```
           </TabItem>
         </Tabs>
    </Steps>
  </TabItem>
</Tabs>

## 2. Creando Cuentas de Prueba

<Tabs>
  <TabItem label="TypeScript">
    En blockchain, todas las transacciones deben provenir de una cuenta. Vamos a crear dos cuentas de prueba: una para enviar monedas (Alice) y otra para recibirlas (Bob).

    <Steps>
      1. Configurar el cliente

         Primero, necesitamos inicializar el cliente de Aptos que se conectará a la blockchain. Abre `transaction.ts` en tu editor y agrega:

         ```typescript filename="transaction.ts"
         import {
           Account,
           Aptos,
           AptosConfig,
           Network,
         } from "@aptos-labs/ts-sdk";

         async function main() {
           // Inicializar el cliente de Aptos
           const config = new AptosConfig({ network: Network.DEVNET });
           const aptos = new Aptos(config);

           console.log("Conectado a Aptos devnet");

           // Más código irá aquí
         }

         main().catch(console.error);
         ```

         <Aside type="note">
           Nos estamos conectando a la devnet de Aptos, que es una red de prueba donde puedes experimentar sin usar monedas reales. La devnet se reinicia periódicamente, así que no almacenes nada importante allí. Puedes explorar el código fuente completo del SDK de TypeScript en el [repositorio aptos-ts-sdk](https://github.com/aptos-labs/aptos-ts-sdk).
         </Aside>

      2. Generar cuentas

         Agrega este código dentro de tu función `main()` para crear dos cuentas - Alice (remitente) y Bob (receptor):

         ```typescript filename="transaction.ts"
         // Generar dos cuentas
         const alice = Account.generate();
         const bob = Account.generate();

         console.log("=== Direcciones ===");
         console.log(`Dirección de Alice: ${alice.accountAddress}`);
         console.log(`Dirección de Bob: ${bob.accountAddress}`);
         ```

         <Aside type="note">
           Cada cuenta tiene una dirección única (como un número de cuenta bancaria) y un par de claves (como tus credenciales de inicio de sesión). La dirección se deriva de la clave pública, mientras que la clave privada se mantiene secreta y se usa para firmar transacciones. Para más detalles sobre cómo funcionan las cuentas en Aptos, consulta [Conceptos básicos de cuentas](/es/network/blockchain/accounts).
         </Aside>

      3. Financiar las cuentas

         Agrega este código después de generar las cuentas para obtener monedas de prueba del faucet:

         ```typescript filename="transaction.ts"
         // Financiar las cuentas con APT de prueba del faucet de devnet
         console.log("\n=== Financiando cuentas ===");
         await aptos.fundAccount({
           accountAddress: alice.accountAddress,
           amount: 100_000_000, // 1 APT = 100,000,000 octas
         });
         console.log("Cuentas financiadas exitosamente");

         // Verificar saldos iniciales
         const aliceBalance = await aptos.getAccountAPTAmount({
           accountAddress: alice.accountAddress,
         });
         const bobBalance = await aptos.getAccountAPTAmount({
           accountAddress: bob.accountAddress,
         });

         console.log("\n=== Saldos Iniciales ===");
         console.log(`Alice: ${aliceBalance} octas`);
         console.log(`Bob: ${bobBalance} octas`);
         ```

      4. Ejecutar el código

         Vamos a probar nuestro código hasta ahora:

         ```shellscript filename="Terminal"
         npx ts-node transaction.ts
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Financiando cuentas ===
         Cuentas financiadas exitosamente

         === Saldos Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas
         ```

         <Aside type="note">
           Las direcciones que veas serán diferentes de las mostradas aquí, ya que se generan aleatoriamente cada vez.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    En blockchain, todas las transacciones deben provenir de una cuenta. Vamos a crear dos cuentas de prueba: una para enviar monedas (Alice) y otra para recibirlas (Bob).

    <Steps>
      1. Configurar el cliente

         Primero, necesitamos inicializar el cliente de Aptos que se conectará a la blockchain. Abre `transaction.py` en tu editor y agrega:

         ```python filename="transaction.py"
         import asyncio
         from aptos_sdk.account import Account
         from aptos_sdk.async_client import FaucetClient, RestClient
         from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument, RawTransaction
         from aptos_sdk.bcs import Serializer
         import time

         # Configuración de red
         NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
         FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

         async def main():
             # Inicializar los clientes
             rest_client = RestClient(NODE_URL)
             faucet_client = FaucetClient(FAUCET_URL, rest_client)

             print("Conectado a Aptos devnet")

             # Más código irá aquí

         if __name__ == "__main__":
             asyncio.run(main())
         ```

         <Aside type="note">
           Nos estamos conectando a la devnet de Aptos, que es una red de prueba donde puedes experimentar sin usar monedas reales. La devnet se reinicia periódicamente, así que no almacenes nada importante allí. Puedes explorar el código fuente completo del SDK de Python en el [repositorio aptos-python-sdk](https://github.com/aptos-labs/aptos-python-sdk).
         </Aside>

      2. Generar cuentas

         Agrega este código dentro de tu función `main()` para crear dos cuentas - Alice (remitente) y Bob (receptor):

         ```python filename="transaction.py"
         # Generar dos cuentas
         alice = Account.generate()
         bob = Account.generate()

         print("=== Direcciones ===")
         print(f"Dirección de Alice: {alice.address()}")
         print(f"Dirección de Bob: {bob.address()}")
         ```

         <Aside type="note">
           Cada cuenta tiene una dirección única (como un número de cuenta bancaria) y un par de claves (como tus credenciales de inicio de sesión). La dirección se deriva de la clave pública, mientras que la clave privada se mantiene secreta y se usa para firmar transacciones. Para más detalles sobre cómo funcionan las cuentas en Aptos, consulta [Conceptos básicos de cuentas](/es/network/blockchain/accounts).
         </Aside>

      3. Financiar las cuentas

         Agrega este código después de generar las cuentas para obtener monedas de prueba del faucet:

         ```python filename="transaction.py"
         # Financiar las cuentas con APT de prueba del faucet de devnet
         print("\n=== Financiando cuentas ===")
         alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
         bob_amount = 0  # Bob comienza con 0 APT

         await faucet_client.fund_account(alice.address(), alice_amount)
         print("Cuenta financiada exitosamente")

         # Verificar saldos iniciales
         alice_balance = await rest_client.account_balance(alice.address())
         bob_balance = await rest_client.account_balance(bob.address())

         print("\n=== Saldos Iniciales ===")
         print(f"Alice: {alice_balance} octas")
         print(f"Bob: {bob_balance} octas")
         ```

      4. Ejecutar el código

         Vamos a probar nuestro código hasta ahora:

         ```shellscript filename="Terminal"
         python transaction.py
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Financiando cuentas ===
         Cuenta financiada exitosamente

         === Saldos Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas
         ```

         <Aside type="note">
           Las direcciones que veas serán diferentes de las mostradas aquí, ya que se generan aleatoriamente cada vez.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 3. Construyendo una Transacción

<Tabs>
  <TabItem label="TypeScript">
    Ahora que tenemos cuentas financiadas, vamos a crear una transacción para transferir monedas de Alice a Bob. Esto es como llenar un formulario especificando qué quieres enviar y a quién.

    <Steps>
      1. Entender la estructura de transacción

         Una transacción en Aptos tiene varios componentes clave:

         1. **Remitente**: La cuenta que inicia la transacción (Alice)
         2. **Función**: La función en cadena a llamar (en este caso, una transferencia de monedas)
         3. **Argumentos**: Datos necesarios para la función (dirección del destinatario y cantidad)
         4. **Parámetros de gas**: Cantidad máxima de gas y precio unitario de gas
         5. **Tiempo de expiración**: Cuando la transacción deja de ser válida si no se ejecuta
         6. **Número de secuencia**: Un contador que previene ataques de repetición

         <Aside type="note">
           Todos los datos en las transacciones de Aptos se serializan usando Binary Canonical Serialization (BCS), un formato compacto y determinístico diseñado para uso blockchain. El SDK maneja esta serialización por ti.

           BCS asegura que los datos de transacción se codifiquen consistentemente a través de diferentes plataformas e idiomas, lo cual es crítico para una blockchain donde la misma transacción podría ser procesada por nodos ejecutando diferentes implementaciones.
         </Aside>

      2. Construir la transacción

         Vamos a agregar código para construir una transacción que transfiere 1000 octas de Alice a Bob:

         Agrega este código a tu función `main()`:

         ```typescript filename="transaction.ts"
         // 1. Construir la transacción
         console.log("\n=== 1. Construyendo la transacción ===");
         const transaction = await aptos.transaction.build.simple({
           sender: alice.accountAddress,
           data: {
             function: "0x1::aptos_account::transfer",
             functionArguments: [bob.accountAddress, 1000], // Transferir 1000 octas
           },
         });
         console.log("Transacción construida exitosamente");

         // Acceder a los detalles de la transacción desde la transacción raw
         const rawTxn = transaction.rawTransaction;
         console.log(`Remitente: ${rawTxn.sender}`);
         console.log(`Número de Secuencia: ${rawTxn.sequence_number}`);
         console.log(`Cantidad Máxima de Gas: ${rawTxn.max_gas_amount}`);
         console.log(`Precio Unitario de Gas: ${rawTxn.gas_unit_price}`);
         console.log(`Timestamp de Expiración: ${new Date(Number(rawTxn.expiration_timestamp_secs) * 1000).toISOString()}`);
         ```

         <Aside type="note">
           La función `0x1::aptos_account::transfer` es una función incorporada en el framework de Aptos que transfiere monedas entre cuentas. El prefijo `0x1` indica que es parte del framework central. Detrás de escena, esta función llama al [código fuente del módulo Coin Move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) para realizar la transferencia real.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Ahora que tenemos cuentas financiadas, vamos a crear una transacción para transferir monedas de Alice a Bob. Esto es como llenar un formulario especificando qué quieres enviar y a quién.

    <Steps>
      1. Entender la estructura de transacción

         Una transacción en Aptos tiene varios componentes clave:

         1. **Remitente**: La cuenta que inicia la transacción (Alice)
         2. **Función**: La función en cadena a llamar (en este caso, una transferencia de monedas)
         3. **Argumentos**: Datos necesarios para la función (dirección del destinatario y cantidad)
         4. **Parámetros de gas**: Cantidad máxima de gas y precio unitario de gas
         5. **Tiempo de expiración**: Cuando la transacción deja de ser válida si no se ejecuta
         6. **Número de secuencia**: Un contador que previene ataques de repetición

         <Aside type="note">
           Todos los datos en las transacciones de Aptos se serializan usando Binary Canonical Serialization (BCS), un formato compacto y determinístico diseñado para uso blockchain. El SDK maneja esta serialización por ti.

           BCS asegura que los datos de transacción se codifiquen consistentemente a través de diferentes plataformas e idiomas, lo cual es crítico para una blockchain donde la misma transacción podría ser procesada por nodos ejecutando diferentes implementaciones.
         </Aside>

      2. Construir la transacción

         Agrega el siguiente código a tu función `main()` para construir una transacción que transfiere 1000 octas de Alice a Bob:

         ```python filename="transaction.py"
         # 1. Construir la transacción
         print("\n=== 1. Construyendo la transacción ===")

         # Crear el payload de la función de entrada
         # Esto especifica qué función llamar y con qué argumentos
         entry_function = EntryFunction.natural(
             "0x1::aptos_account",  # Dirección y nombre del módulo
             "transfer",            # Nombre de la función
             [],                    # Argumentos de tipo (vacío para esta función)
             [
                 # Argumentos de función con su tipo de serialización
                 TransactionArgument(bob.address(), Serializer.struct),  # Dirección del destinatario
                 TransactionArgument(1000, Serializer.u64),              # Cantidad a transferir (1000 octas)
             ],
         )

         # Obtener el ID de cadena para la transacción
         chain_id = await rest_client.chain_id()

         # Obtener el número de secuencia actual del remitente
         account_data = await rest_client.account(alice.address())
         sequence_number = int(account_data["sequence_number"])

         # Crear la transacción raw con todos los campos requeridos
         raw_transaction = RawTransaction(
             sender=alice.address(),                                    # Dirección del remitente
             sequence_number=sequence_number,                           # Número de secuencia para prevenir ataques de repetición
             payload=TransactionPayload(entry_function),                # La función a llamar
             max_gas_amount=2000,                                       # Unidades máximas de gas a usar
             gas_unit_price=100,                                        # Precio por unidad de gas en octas
             expiration_timestamps_secs=int(time.time()) + 600,         # Expira en 10 minutos
             chain_id=chain_id,                                         # ID de cadena para asegurar la red correcta
         )

         print("Transacción construida exitosamente")
         print(f"Remitente: {raw_transaction.sender}")
         print(f"Número de Secuencia: {raw_transaction.sequence_number}")
         print(f"Cantidad Máxima de Gas: {raw_transaction.max_gas_amount}")
         print(f"Precio Unitario de Gas: {raw_transaction.gas_unit_price}")
         print(f"Timestamp de Expiración: {time.ctime(raw_transaction.expiration_timestamps_secs)}")
         ```

         <Aside type="note">
           La función `0x1::aptos_account::transfer` es una función incorporada en el framework de Aptos que transfiere monedas entre cuentas. El prefijo `0x1` indica que es parte del framework central. Detrás de escena, esta función llama al [código fuente del módulo Coin Move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) para realizar la transferencia real.

           El SDK de Python usa varios componentes clave para construir transacciones:

           - `EntryFunction.natural()` crea una referencia de función Move callable
           - `TransactionArgument` con tipos `Serializer` asegura la serialización BCS apropiada
           - `TransactionPayload` envuelve la función de entrada para inclusión en la transacción
           - `RawTransaction` combina todos los parámetros de transacción en una transacción completa

           Este enfoque en capas te da control detallado sobre la construcción de transacciones.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 4. Simulando la Transacción

<Tabs>
  <TabItem label="TypeScript">
    Antes de enviar una transacción, es sabio simularla primero para estimar el costo de gas. Esto es como verificar los costos de envío antes de enviar un paquete.

    <Steps>
      1. Simular la transacción

         Agrega este código después de construir la transacción:

         ```typescript filename="transaction.ts"
         // 2. Simular la transacción
         console.log("\n=== 2. Simulando la transacción ===");
         const [simulationResult] = await aptos.transaction.simulate.simple({
           signerPublicKey: alice.publicKey,
           transaction,
         });

         const gasUsed = parseInt(simulationResult.gas_used);
         const gasUnitPrice = parseInt(simulationResult.gas_unit_price);
         console.log(`Unidades de gas estimadas: ${gasUsed}`);
         console.log(`Costo de gas estimado: ${gasUsed * gasUnitPrice} octas`);
         console.log(`La transacción ${simulationResult.success ? "tendría éxito" : "fallaría"}`);
         ```

         <Aside type="note">
           El gas es la tarifa computacional pagada para procesar transacciones en la blockchain. El costo total se calcula como `gas_used × gas_unit_price`. Durante la simulación, la blockchain ejecuta la transacción en un entorno temporal para estimar estos costos sin hacer cambios permanentes al estado de la blockchain. Esto te ayuda a evitar transacciones fallidas debido a gas insuficiente.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Antes de enviar una transacción, es sabio simularla primero para estimar el costo de gas. Esto es como verificar los costos de envío antes de enviar un paquete.

    <Steps>
      1. Simular la transacción

         Agrega este código después de construir la transacción:

         ```python filename="transaction.py"
         # 2. Simular la transacción
         print("\n=== 2. Simulando la transacción ===")

         # Crear una transacción BCS para simulación
         # Esto no envía realmente la transacción a la blockchain
         simulation_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(entry_function))

         # Simular la transacción para estimar costos de gas y verificar errores
         simulation_result = await rest_client.simulate_transaction(simulation_transaction, alice)

         # Extraer y mostrar los resultados de simulación
         gas_used = int(simulation_result[0]['gas_used'])
         gas_unit_price = int(simulation_result[0]['gas_unit_price'])
         success = simulation_result[0]['success']

         print(f"Unidades de gas estimadas: {gas_used}")
         print(f"Costo de gas estimado: {gas_used * gas_unit_price} octas")
         print(f"La transacción {'tendría éxito' if success else 'fallaría'}")
         ```

         <Aside type="note">
           El gas es la tarifa computacional pagada para procesar transacciones en la blockchain. El costo total se calcula como `gas_used × gas_unit_price`. Durante la simulación, la blockchain ejecuta la transacción en un entorno temporal para estimar estos costos sin hacer cambios permanentes al estado de la blockchain. Esto te ayuda a evitar transacciones fallidas debido a gas insuficiente.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 5. Firmando y Enviando la Transacción

<Tabs>
  <TabItem label="TypeScript">
    Ahora que hemos construido y simulado la transacción, necesitamos firmarla con la clave privada de Alice y enviarla a la blockchain.

    <Steps>
      1. Firmar la transacción

         Firmar prueba que Alice autorizó esta transacción:

         Agrega este código después de simular la transacción:

         ```typescript filename="transaction.ts"
         // 3. Firmar la transacción
         console.log("\n=== 3. Firmando la transacción ===");
         const senderAuthenticator = aptos.transaction.sign({
           signer: alice,
           transaction,
         });
         console.log("Transacción firmada exitosamente");
         ```

         <Aside type="note">
           Las firmas digitales funcionan como un sello personal o firma en el mundo físico. Prueban que la transacción fue autorizada por el propietario de la cuenta (quien tiene la clave privada) y no han sido manipuladas.
         </Aside>

      2. Enviar la transacción

         Agrega este código después de firmar la transacción para enviar la transacción firmada a la blockchain:

         ```typescript filename="transaction.ts"
         // 4. Enviar la transacción
         console.log("\n=== 4. Enviando la transacción ===");
         const pendingTransaction = await aptos.transaction.submit.simple({
           transaction,
           senderAuthenticator,
         });
         console.log(`Transacción enviada con hash: ${pendingTransaction.hash}`);
         ```

         <Aside type="note">
           El hash de transacción es un identificador único para tu transacción, similar a un número de seguimiento para un paquete. Al enviar una transacción, la blockchain de Aptos realiza varias verificaciones de validación, incluyendo verificar la firma de la transacción y asegurar que el número de secuencia no haya sido usado antes (previniendo ataques de repetición). Puedes usar el hash para verificar el estado de tu transacción en el [Explorador de Aptos](https://explorer.aptoslabs.com/) o vía la [API REST](/es/build/apis/fullnode-rest-api).
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Ahora que hemos construido y simulado la transacción, necesitamos firmarla con la clave privada de Alice y enviarla a la blockchain.

    <Steps>
      1. Firmar la transacción

         Firmar prueba que Alice autorizó esta transacción:

         Agrega este código después de simular la transacción:

         ```python filename="transaction.py"
         # 3. Firmar la transacción
         print("\n=== 3. Firmando la transacción ===")

         # Firmar la transacción raw con la clave privada del remitente
         # Esto crea una firma criptográfica que prueba que el remitente autorizó esta transacción
         signed_transaction = await rest_client.create_bcs_signed_transaction(
             alice,                           # Cuenta con la clave privada
             TransactionPayload(entry_function),  # El payload de nuestra transacción
             sequence_number=sequence_number  # Usar el mismo número de secuencia que antes
         )

         print("Transacción firmada exitosamente")
         # No podemos extraer fácilmente la firma del objeto de transacción firmada,
         # pero podemos confirmar que fue creada
         ```

         <Aside type="note">
           Las firmas digitales funcionan como un sello personal o firma en el mundo físico. Prueban que la transacción fue autorizada por el propietario de la cuenta (quien tiene la clave privada) y no han sido manipuladas.
         </Aside>

      2. Enviar la transacción

         Agrega este código después de firmar la transacción para enviar la transacción firmada a la blockchain:

         ```python filename="transaction.py"
         # 4. Enviar la transacción
         print("\n=== 4. Enviando la transacción ===")

         # Enviar la transacción firmada a la blockchain
         # Esto transmite la transacción a la red para procesamiento
         tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)

         print(f"Transacción enviada con hash: {tx_hash}")
         ```

         <Aside type="note">
           El hash de transacción es un identificador único para tu transacción, similar a un número de seguimiento para un paquete. Al enviar una transacción, la blockchain de Aptos realiza varias verificaciones de validación, incluyendo verificar la firma de la transacción y asegurar que el número de secuencia no haya sido usado antes (previniendo ataques de repetición). Puedes usar el hash para verificar el estado de tu transacción en el [Explorador de Aptos](https://explorer.aptoslabs.com/) o vía la [API REST](/es/build/apis/fullnode-rest-api).
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 6. Esperando Confirmación

<Tabs>
  <TabItem label="TypeScript">
    Después de enviar una transacción, necesitamos esperar a que sea procesada por la blockchain. Esto es como esperar a que un paquete sea entregado.

    <Steps>
      1. Esperar completación de la transacción

         Agrega este código después de enviar la transacción:

         ```typescript filename="transaction.ts"
         // 5. Esperar a que la transacción se complete
         console.log("\n=== 5. Esperando completación de la transacción ===");
         const txnResult = await aptos.waitForTransaction({
           transactionHash: pendingTransaction.hash,
         });
         console.log(`Transacción completada con estado: ${txnResult.success ? "ÉXITO" : "FALLIDO"}`);

         // Si quieres ver más detalles sobre la transacción:
         console.log(`Estado VM: ${txnResult.vm_status}`);
         console.log(`Gas usado: ${txnResult.gas_used}`);
         ```

      2. Verificar los resultados

         Agrega este código después de esperar la transacción para verificar los saldos y confirmar que la transferencia funcionó:

         ```typescript filename="transaction.ts"
         // Verificar saldos finales
         const aliceFinalBalance = await aptos.getAccountAPTAmount({
           accountAddress: alice.accountAddress,
         });
         const bobFinalBalance = await aptos.getAccountAPTAmount({
           accountAddress: bob.accountAddress,
         });

         console.log("\n=== Saldos Finales ===");
         console.log(`Alice: ${aliceFinalBalance} octas (gastó ${aliceBalance - aliceFinalBalance} octas en transferencia y gas)`);
         console.log(`Bob: ${bobFinalBalance} octas (recibió 1000 octas)`);
         ```

      3. Ejecutar el código completo

         ```shellscript filename="Terminal"
         npx ts-node transaction.ts
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Financiando cuentas ===
         Cuentas financiadas exitosamente

         === Saldos Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas

         === 1. Construyendo la transacción ===
         Transacción construida exitosamente
         Remitente: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Número de Secuencia: 0
         Cantidad Máxima de Gas: 20000
         Precio Unitario de Gas: 100
         Timestamp de Expiración: 2025-03-05T22:59:21.000Z

         === 2. Simulando la transacción ===
         Unidades de gas estimadas: 146
         Costo de gas estimado: 14600 octas
         La transacción tendría éxito

         === 3. Firmando la transacción ===
         Transacción firmada exitosamente

         === 4. Enviando la transacción ===
         Transacción enviada con hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

         === 5. Esperando completación de la transacción ===
         Transacción completada con estado: ÉXITO
         Estado VM: Ejecutado exitosamente
         Gas usado: 146

         === Saldos Finales ===
         Alice: 99984400 octas (gastó 15600 octas en transferencia y gas)
         Bob: 1000 octas (recibió 1000 octas)
         ```

         <Aside type="note">
           Observa que el saldo de Alice disminuyó en más de 1000 octas. La cantidad extra es la tarifa de gas pagada para procesar la transacción. Detrás de escena, al verificar saldos, el SDK consulta el recurso CoinStore para AptosCoin (`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`) y lee el valor almacenado actual. Esto demuestra cómo el SDK abstrae interacciones complejas de blockchain en llamadas de función simples.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Después de enviar una transacción, necesitamos esperar a que sea procesada por la blockchain. Esto es como esperar a que un paquete sea entregado.

    <Steps>
      1. Esperar completación de la transacción

         Agrega este código después de enviar la transacción:

         ```python filename="transaction.py"
         # 5. Esperar a que la transacción se complete
         print("\n=== 5. Esperando completación de la transacción ===")

         # Esperar a que la transacción sea procesada por la blockchain
         # Esto sondea la blockchain hasta que la transacción sea confirmada
         await rest_client.wait_for_transaction(tx_hash)

         # Obtener los detalles de la transacción para verificar su estado
         transaction_details = await rest_client.transaction_by_hash(tx_hash)
         success = transaction_details["success"]
         vm_status = transaction_details["vm_status"]
         gas_used = transaction_details["gas_used"]

         print(f"Transacción completada con estado: {'ÉXITO' if success else 'FALLIDO'}")
         print(f"Estado VM: {vm_status}")
         print(f"Gas usado: {gas_used}")
         ```

      2. Verificar los resultados

         Agrega este código después de esperar la transacción para verificar los saldos y confirmar que la transferencia funcionó:

         ```python filename="transaction.py"
         # Verificar saldos finales
         alice_final_balance = await rest_client.account_balance(alice.address())
         bob_final_balance = await rest_client.account_balance(bob.address())

         print("\n=== Saldos Finales ===")
         print(f"Alice: {alice_final_balance} octas (gastó {alice_balance - alice_final_balance} octas en transferencia y gas)")
         print(f"Bob: {bob_final_balance} octas (recibió 1000 octas)")
         ```

      3. Ejecutar el código completo

         ```shellscript filename="Terminal"
         python transaction.py
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Financiando cuentas ===
         Cuentas financiadas exitosamente

         === Saldos Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas

         === 1. Construyendo la transacción ===
         Transacción construida exitosamente
         Remitente: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Número de Secuencia: 0
         Cantidad Máxima de Gas: 2000
         Precio Unitario de Gas: 100
         Timestamp de Expiración: Wed Mar 05 22:59:21 2025

         === 2. Simulando la transacción ===
         Unidades de gas estimadas: 146
         Costo de gas estimado: 14600 octas
         La transacción tendría éxito

         === 3. Firmando la transacción ===
         Transacción firmada exitosamente

         === 4. Enviando la transacción ===
         === 3. Firmando la transacción ===
         Transacción firmada exitosamente

         === 4. Enviando la transacción ===
         Transacción enviada con hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

         === 5. Esperando completación de la transacción ===
         Transacción completada con estado: ÉXITO
         Estado VM: Ejecutado exitosamente
         Gas usado: 146

         === Saldos Finales ===
         Alice: 99984400 octas (gastó 15600 octas en transferencia y gas)
         Bob: 1000 octas (recibió 1000 octas)
         ```

         <Aside type="note">
           Observa que el saldo de Alice disminuyó en más de 1000 octas. La cantidad extra es la tarifa de gas pagada para procesar la transacción. Detrás de escena, al verificar saldos, el SDK consulta el recurso CoinStore para AptosCoin (`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`) y lee el valor almacenado actual.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 7. (Opcional) Explora Tu Transacción En Cadena

Ahora que has ejecutado exitosamente una transacción, puedes explorarla en el Explorador de Aptos. Esto te ayudará a entender cómo se registran las transacciones en la blockchain y qué información está disponible públicamente.

<Steps>
  1. Copia el hash de tu transacción

     Desde la salida de tu terminal, copia el hash de transacción que se imprimió después del envío. Se ve algo como esto:

     ```
     Transacción enviada con hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc
     ```

  2. Abre el Explorador de Aptos

     Ve al [Explorador de Aptos](https://explorer.aptoslabs.com/?network=devnet).

  3. Asegúrate de estar en la red Devnet

     Busca "Devnet" en la esquina superior derecha, o cambia de red haciendo clic en el dropdown y seleccionando Devnet.

     ![Cambiando a la red Devnet en el Explorador de Aptos](~/images/screenshots/explorer_devnet.png)

  4. Busca tu transacción

     Pega el hash de tu transacción en la barra de búsqueda en el medio de la página.

     <Aside type="caution">
       ¡No presiones enter! Hay un bug conocido donde buscar con Enter no funciona.
     </Aside>

  5. Ve los detalles de la transacción

     Espera a que aparezcan los resultados, luego haz clic en el hash de transacción para ver sus detalles.

     Deberías ver información sobre tu transacción, incluyendo:

     - Estado (debería ser "Success")
     - Timestamp
     - Gas usado
     - Direcciones del remitente y destinatario
     - Cantidad transferida

  6. Explora más

     Desde la página de detalles de la transacción, puedes:

     - Hacer clic en las direcciones del remitente o destinatario para ver los detalles de sus cuentas
     - Ver los cambios exactos hechos al estado de la blockchain
     - Ver el payload y argumentos de la transacción

     <Aside type="note">
       El Explorador es una herramienta poderosa para depurar transacciones y entender la actividad blockchain. Los desarrolladores lo usan frecuentemente para verificar que sus transacciones se ejecutaron como esperado e investigar cualquier problema.
     </Aside>
</Steps>

## 8. Próximos Pasos

¡Felicitaciones! Has creado y ejecutado exitosamente tu primera transacción en la blockchain de Aptos. Aquí hay algunas sugerencias para qué explorar a continuación:

**Aprende sobre transacciones más complejas**:

- [Firmas Multi-Agente](/es/build/sdks/ts-sdk/building-transactions/multi-agent-transactions) - Transacciones que requieren múltiples firmantes
- [Patrocinio de Transacciones](/es/build/sdks/ts-sdk/building-transactions/sponsoring-transactions) - Hacer que otra cuenta pague las tarifas de gas
- [Agrupación de Transacciones](/es/build/sdks/ts-sdk/building-transactions/batching-transactions) - Enviar múltiples transacciones eficientemente

<Aside type="note">
  Los enlaces anteriores son para el SDK de Typescript pero los principios son los mismos si estás usando Python o Rust.
</Aside>

**Explora contratos inteligentes o conceptos básicos de cuentas**:

- [Tu Primer Módulo Move](/es/build/guides/first-move-module) - Crea tu propio contrato inteligente
- [Conceptos Básicos de Cuentas](/es/network/blockchain/accounts)

[¡Únete al Discord de Aptos](https://discord.gg/aptoslabs) y comparte lo que estás construyendo!

## Muestra Completa de Código

Las muestras completas de código a continuación combinan todos los fragmentos que hemos cubierto en este tutorial:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript filename="transaction.ts"
    import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

    async function main() {
      // Initialize the Aptos client
      const config = new AptosConfig({ network: Network.DEVNET });
      const aptos = new Aptos(config);

      console.log("Connected to Aptos devnet");

      // More code will go here
      // Generate two accounts
      const alice = Account.generate();
      const bob = Account.generate();

      console.log("=== Addresses ===");
      console.log(`Alice's address: ${alice.accountAddress}`);
      console.log(`Bob's address: ${bob.accountAddress}`);

      // Fund the accounts with test APT from the devnet faucet
      console.log("\n=== Funding accounts ===");
      await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 100_000_000, // 1 APT = 100,000,000 octas
      });
      await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 0, // Bob starts with 0 APT
      });
      console.log("Accounts funded successfully");

      // Check initial balances
      const aliceBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Initial Balances ===");
      console.log(`Alice: ${aliceBalance} octas`);
      console.log(`Bob: ${bobBalance} octas`);

      // 1. Build the transaction
      console.log("\n=== 1. Building the transaction ===");
      const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        data: {
          function: "0x1::aptos_account::transfer",
          functionArguments: [bob.accountAddress, 1000], // Transfer 1000 octas
        },
      });
      console.log("Transaction built successfully");
      // Use type assertion to bypass TypeScript's type checking
      const txnAny = transaction as any;
      console.log(`Sender: ${alice.accountAddress}`); // Use the known sender address
      console.log(`Sequence Number: ${txnAny.sequenceNumber || "N/A"}`);
      console.log(`Max Gas Amount: ${txnAny.maxGasAmount || "N/A"}`);
      console.log(`Gas Unit Price: ${txnAny.gasUnitPrice || "N/A"}`);
      console.log(
        `Expiration Timestamp: ${new Date(
          Number(txnAny.expirationTimestampSecs || 0) * 1000
        ).toISOString()}`
      );

      // 2. Simulate the transaction
      console.log("\n=== 2. Simulating the transaction ===");
      const [simulationResult] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        transaction,
      });

      console.log(`Estimated gas units: ${simulationResult.gas_used}`);
      console.log(
        `Estimated gas cost: ${
          Number(simulationResult.gas_used) * Number(simulationResult.gas_unit_price)
        } octas`
      );
      console.log(
        `Transaction would ${simulationResult.success ? "succeed" : "fail"}`
      );

      // 3. Sign the transaction
      console.log("\n=== 3. Signing the transaction ===");
      const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
      });
      console.log("Transaction signed successfully");
      // Use type assertion to bypass TypeScript's type checking
      const authAny = senderAuthenticator as any;
      const signatureStr = typeof authAny.signature === 'string'
        ? authAny.signature
        : JSON.stringify(authAny.signature || '');
      console.log(`Signature: ${signatureStr.slice(0, 20)}...`);

      // 4. Submit the transaction
      console.log("\n=== 4. Submitting the transaction ===");
      const pendingTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
      });
      console.log(`Transaction submitted with hash: ${pendingTransaction.hash}`);

      // 5. Wait for the transaction to complete
      console.log("\n=== 5. Waiting for transaction completion ===");
      const txnResult = await aptos.waitForTransaction({
        transactionHash: pendingTransaction.hash,
      });
      console.log(
        `Transaction completed with status: ${
          txnResult.success ? "SUCCESS" : "FAILURE"
        }`
      );

      // If you want to see more details about the transaction:
      console.log(`VM Status: ${txnResult.vm_status}`);
      console.log(`Gas used: ${txnResult.gas_used}`);

      // Check final balances
      const aliceFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Final Balances ===");
      console.log(
        `Alice: ${aliceFinalBalance} octas (spent ${
          aliceBalance - aliceFinalBalance
        } octas on transfer and gas)`
      );
      console.log(`Bob: ${bobFinalBalance} octas (received 1000 octas)`);
    }

    main().catch(console.error);
    ```
  </TabItem>

  <TabItem label="Python">
    ```python filename="transaction.py"
    import asyncio
    from aptos_sdk.account import Account
    from aptos_sdk.async_client import FaucetClient, RestClient
    from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument, RawTransaction
    from aptos_sdk.bcs import Serializer
    import time

    # Network configuration
    NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
    FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

    async def main():
        # Initialize the clients
        rest_client = RestClient(NODE_URL)
        faucet_client = FaucetClient(FAUCET_URL, rest_client)

        print("Connected to Aptos devnet")

        # Generate two accounts
        alice = Account.generate()
        bob = Account.generate()

        print("=== Addresses ===")
        print(f"Alice's address: {alice.address()}")
        print(f"Bob's address: {bob.address()}")
            # More code will go here
            # Fund the accounts with test APT from the devnet faucet
        print("\n=== Funding accounts ===")
        alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
        bob_amount = 0  # Bob starts with 0 APT

        await faucet_client.fund_account(alice.address(), alice_amount)
        await faucet_client.fund_account(bob.address(), bob_amount)
        print("Accounts funded successfully")

        # Check initial balances
        alice_balance = await rest_client.account_balance(alice.address())
        bob_balance = await rest_client.account_balance(bob.address())

        print("\n=== Initial Balances ===")
        print(f"Alice: {alice_balance} octas")
        print(f"Bob: {bob_balance} octas")

        # 1. Build the transaction
        print("\n=== 1. Building the transaction ===")

        # Create the entry function payload
        # This specifies which function to call and with what arguments
        entry_function = EntryFunction.natural(
            "0x1::aptos_account",  # Module address and name
            "transfer",            # Function name
            [],                    # Type arguments (empty for this function)
            [
                # Function arguments with their serialization type
                TransactionArgument(bob.address(), Serializer.struct),  # Recipient address
                TransactionArgument(1000, Serializer.u64),              # Amount to transfer (1000 octas)
            ],
        )

        # Get the chain ID for the transaction
        chain_id = await rest_client.chain_id()

        # Get the sender's current sequence number
        account_data = await rest_client.account(alice.address())
        sequence_number = int(account_data["sequence_number"])

        # Create the raw transaction with all required fields
        raw_transaction = RawTransaction(
            sender=alice.address(),                                    # Sender's address
            sequence_number=sequence_number,                           # Sequence number to prevent replay attacks
            payload=TransactionPayload(entry_function),                # The function to call
            max_gas_amount=2000,                                       # Maximum gas units to use
            gas_unit_price=100,                                        # Price per gas unit in octas
            expiration_timestamps_secs=int(time.time()) + 600,         # Expires in 10 minutes
            chain_id=chain_id,                                         # Chain ID to ensure correct network
        )

        print("Transaction built successfully")
        print(f"Sender: {raw_transaction.sender}")
        print(f"Sequence Number: {raw_transaction.sequence_number}")
        print(f"Max Gas Amount: {raw_transaction.max_gas_amount}")
        print(f"Gas Unit Price: {raw_transaction.gas_unit_price}")
        print(f"Expiration Timestamp: {time.ctime(raw_transaction.expiration_timestamps_secs)}")

        # 2. Simulate the transaction
        print("\n=== 2. Simulating the transaction ===")

        # Create a BCS transaction for simulation
        # This doesn't actually submit the transaction to the blockchain
        simulation_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(entry_function))

        # Simulate the transaction to estimate gas costs and check for errors
        simulation_result = await rest_client.simulate_transaction(simulation_transaction, alice)

        # Extract and display the simulation results
        gas_used = int(simulation_result[0]['gas_used'])
        gas_unit_price = int(simulation_result[0]['gas_unit_price'])
        success = simulation_result[0]['success']

        print(f"Estimated gas units: {gas_used}")
        print(f"Estimated gas cost: {gas_used * gas_unit_price} octas")
        print(f"Transaction would {'succeed' if success else 'fail'}")

        # 3. Sign the transaction
        print("\n=== 3. Signing the transaction ===")

        # Sign the raw transaction with the sender's private key
        # This creates a cryptographic signature that proves the sender authorized this transaction
        signed_transaction = await rest_client.create_bcs_signed_transaction(
            alice,                                  # Account with the private key
            TransactionPayload(entry_function),     # The payload from our transaction
            sequence_number=sequence_number         # Use the same sequence number as before
        )

        print("Transaction signed successfully")
        # We can't easily extract the signature from the signed transaction object,
        # but we can confirm it was created

        # 4. Submit the transaction
        print("\n=== 4. Submitting the transaction ===")

        # Submit the signed transaction to the blockchain
        # This broadcasts the transaction to the network for processing
        tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)

        print(f"Transaction submitted with hash: {tx_hash}")

        # 5. Wait for the transaction to complete
        print("\n=== 5. Waiting for transaction completion ===")

        # Wait for the transaction to be processed by the blockchain
        # This polls the blockchain until the transaction is confirmed
        await rest_client.wait_for_transaction(tx_hash)

        # Get the transaction details to check its status
        transaction_details = await rest_client.transaction_by_hash(tx_hash)
        success = transaction_details["success"]
        vm_status = transaction_details["vm_status"]
        gas_used = transaction_details["gas_used"]

        print(f"Transaction completed with status: {'SUCCESS' if success else 'FAILURE'}")
        print(f"VM Status: {vm_status}")
        print(f"Gas used: {gas_used}")

        # Check final balances
        alice_final_balance = await rest_client.account_balance(alice.address())
        bob_final_balance = await rest_client.account_balance(bob.address())

        print("\n=== Final Balances ===")
        print(f"Alice: {alice_final_balance} octas (spent {alice_balance - alice_final_balance} octas on transfer and gas)")
        print(f"Bob: {bob_final_balance} octas (received 1000 octas)")
    if __name__ == "__main__":
        asyncio.run(main())
    ```
  </TabItem>
</Tabs>
