---
title: "Tu Primera Transacción"
description: "Crea y envía tu primera transacción en la blockchain de Aptos - transfiere coins entre cuentas con ejemplos en TypeScript y Python."
sidebar:
  label: "Tu Primera Transacción"
---

import { Aside, Steps, TabItem, Tabs } from '@astrojs/starlight/components';

Las transacciones son la forma fundamental de cambiar la data en la blockchain de Aptos. Piénsalo como enviar un paquete: necesitas especificar qué envías, a quién va dirigido, y luego rastrearlo hasta que se confirme el delivery. En términos de blockchain, las transacciones te permiten transferir coins, llamar funciones de smart contracts y actualizar el estado on-chain.

Este tutorial te guiará para crear y hacer submit de tu primera transacción en la blockchain de Aptos. Aprenderás cómo:

1. Configurar tu entorno de desarrollo
2. Crear cuentas de prueba y fondearlas
3. Construir una transacción para transferir coins
4. Simular la transacción para estimar costos
5. Firmar y hacer submit de la transacción
6. Verificar que la transacción se ejecutó exitosamente

<Aside type="note">
  Este tutorial se basa en conceptos de la blockchain de Aptos. Si eres nuevo en el desarrollo blockchain, no te preocupes, explicaremos los conceptos clave en el camino.

  Puedes saltar al [ejemplo de código completo](#full-code-sample) o seguir leyendo paso a paso.
</Aside>

## 1. Configurando tu Entorno

<Tabs>
  <TabItem label="TypeScript">
    Antes de que podamos crear transacciones, necesitamos configurar nuestro entorno de desarrollo con las herramientas y SDKs necesarios.

    <Steps>
      1. Instalar el SDK de TypeScript

         Instala el SDK de TypeScript usando tu package manager preferido:

         <Tabs>
           <TabItem label="npm">
             ```shellscript filename="Terminal"
             npm install @aptos-labs/ts-sdk
             ```
           </TabItem>

           <TabItem label="yarn">
             ```shellscript filename="Terminal"
             yarn add @aptos-labs/ts-sdk
             ```
           </TabItem>

           <TabItem label="pnpm">
             ```shellscript filename="Terminal"
             pnpm add @aptos-labs/ts-sdk
             ```
           </TabItem>
         </Tabs>

      2. Crear un directorio para el proyecto

         Crea un directorio nuevo para tu proyecto:

         ```shellscript filename="Terminal"
         mkdir my-first-transaction
         cd my-first-transaction
         ```

      3. Crear un archivo nuevo

         Crea un archivo nuevo llamado `transaction.ts`:

         <Tabs>
           <TabItem label="Mac/Linux">
             ```shellscript filename="Terminal"
             touch transaction.ts
             ```
           </TabItem>

           <TabItem label="Windows">
             ```shellscript filename="Terminal"
             type nul > transaction.ts
             ```
           </TabItem>
         </Tabs>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Antes de que podamos crear transacciones, necesitamos configurar nuestro entorno de desarrollo con las herramientas y SDKs necesarios.

    <Steps>
      1. Instalar el SDK de Python

         Instala el SDK de Python usando pip:

         ```shellscript filename="Terminal"
         pip install aptos-sdk
         ```

      2. Crear un directorio para el proyecto

         Crea un directorio nuevo para tu proyecto:

         ```shellscript filename="Terminal"
         mkdir my-first-transaction
         cd my-first-transaction
         ```

      3. Crear un archivo nuevo

         Crea un archivo nuevo llamado `transaction.py`:

         <Tabs>
           <TabItem label="Mac/Linux">
             ```shellscript filename="Terminal"
             touch transaction.py
             ```
           </TabItem>

           <TabItem label="Windows">
             ```shellscript filename="Terminal"
             type nul > transaction.py
             ```
           </TabItem>
         </Tabs>
    </Steps>
  </TabItem>
</Tabs>

## 2. Creando Cuentas de Prueba

<Tabs>
  <TabItem label="TypeScript">
    En blockchain, todas las transacciones deben venir de una cuenta (account). Vamos a crear dos cuentas de prueba: una para enviar coins (Alice) y otra para recibirlos (Bob).

    <Steps>
      1. Configurar el cliente

         Primero, necesitamos inicializar el cliente de Aptos que se conectará a la blockchain. Abre `transaction.ts` en tu editor y agrega:

         ```typescript filename="transaction.ts"
         import {
           Account,
           Aptos,
           AptosConfig,
           Network,
         } from "@aptos-labs/ts-sdk";

         async function main() {
           // Inicializar el cliente de Aptos
           const config = new AptosConfig({ network: Network.DEVNET });
           const aptos = new Aptos(config);

           console.log("Conectado a Aptos devnet");

           // Más código irá aquí
         }

         main().catch(console.error);
         ```

         <Aside type="note">
           Nos estamos conectando a la devnet de Aptos, que es una red de prueba donde puedes experimentar sin usar coins reales. La devnet se reinicia periódicamente, así que no guardes nada importante ahí. Puedes explorar el código fuente completo del SDK de TypeScript en el [repositorio aptos-ts-sdk](https://github.com/aptos-labs/aptos-ts-sdk).
         </Aside>

      2. Generar cuentas

         Agrega este código dentro de tu función `main()` para crear dos cuentas: Alice (sender) y Bob (receiver):

         ```typescript filename="transaction.ts"
         // Generar dos cuentas
         const alice = Account.generate();
         const bob = Account.generate();

         console.log("=== Direcciones ===");
         console.log(`Dirección de Alice: ${alice.accountAddress}`);
         console.log(`Dirección de Bob: ${bob.accountAddress}`);
         ```

         <Aside type="note">
           Cada cuenta tiene una dirección única (como un número de cuenta bancaria) y un keypair (como tus credenciales de login). La dirección se deriva de la public key, mientras que la private key se mantiene secreta y se usa para firmar transacciones. Para más detalles sobre cómo funcionan las cuentas en Aptos, mira [Conceptos básicos de cuentas](/es/network/blockchain/accounts).
         </Aside>

      3. Fondear las cuentas

         Agrega este código después de generar las cuentas para obtener coins de prueba desde el faucet:

         ```typescript filename="transaction.ts"
         // Fondear las cuentas con APT de prueba del faucet de devnet
         console.log("\n=== Fondeando cuentas ===");
         await aptos.fundAccount({
           accountAddress: alice.accountAddress,
           amount: 100_000_000, // 1 APT = 100,000,000 octas
         });
         console.log("Cuentas fondeadas exitosamente");

         // Revisar balances iniciales
         const aliceBalance = await aptos.getAccountAPTAmount({
           accountAddress: alice.accountAddress,
         });
         const bobBalance = await aptos.getAccountAPTAmount({
           accountAddress: bob.accountAddress,
         });

         console.log("\n=== Balances Iniciales ===");
         console.log(`Alice: ${aliceBalance} octas`);
         console.log(`Bob: ${bobBalance} octas`);
         ```

      4. Correr el código

         Probemos nuestro código hasta ahora:

         ```shellscript filename="Terminal"
         npx ts-node transaction.ts
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Fondeando cuentas ===
         Cuentas fondeadas exitosamente

         === Balances Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas
         ```

         <Aside type="note">
           Las direcciones que veas serán diferentes a las mostradas aquí, ya que se generan aleatoriamente cada vez.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    En blockchain, todas las transacciones deben venir de una cuenta (account). Vamos a crear dos cuentas de prueba: una para enviar coins (Alice) y otra para recibirlos (Bob).

    <Steps>
      1. Configurar el cliente

         Primero, necesitamos inicializar el cliente de Aptos que se conectará a la blockchain. Abre `transaction.py` en tu editor y agrega:

         ```python filename="transaction.py"
         import asyncio
         from aptos_sdk.account import Account
         from aptos_sdk.async_client import FaucetClient, RestClient
         from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument, RawTransaction
         from aptos_sdk.bcs import Serializer
         import time

         # Configuración de la red
         NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
         FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

         async def main():
             # Inicializar los clientes
             rest_client = RestClient(NODE_URL)
             faucet_client = FaucetClient(FAUCET_URL, rest_client)

             print("Conectado a Aptos devnet")

             # Más código irá aquí

         if __name__ == "__main__":
             asyncio.run(main())
         ```

         <Aside type="note">
           Nos estamos conectando a la devnet de Aptos, que es una red de prueba donde puedes experimentar sin usar coins reales. La devnet se reinicia periódicamente, así que no guardes nada importante ahí. Puedes explorar el código fuente completo del SDK de Python en el [repositorio aptos-python-sdk](https://github.com/aptos-labs/aptos-python-sdk).
         </Aside>

      2. Generar cuentas

         Agrega este código dentro de tu función `main()` para crear dos cuentas: Alice (sender) y Bob (receiver):

         ```python filename="transaction.py"
         # Generar dos cuentas
         alice = Account.generate()
         bob = Account.generate()

         print("=== Direcciones ===")
         print(f"Dirección de Alice: {alice.address()}")
         print(f"Dirección de Bob: {bob.address()}")
         ```

         <Aside type="note">
           Cada cuenta tiene una dirección única (como un número de cuenta bancaria) y un keypair (como tus credenciales de login). La dirección se deriva de la public key, mientras que la private key se mantiene secreta y se usa para firmar transacciones. Para más detalles sobre cómo funcionan las cuentas en Aptos, mira [Conceptos básicos de cuentas](/es/network/blockchain/accounts).
         </Aside>

      3. Fondear las cuentas

         Agrega este código después de generar las cuentas para obtener coins de prueba desde el faucet:

         ```python filename="transaction.py"
         # Fondear las cuentas con APT de prueba del faucet de devnet
         print("\n=== Fondeando cuentas ===");
         alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
         bob_amount = 0  # Bob comienza con 0 APT

         await faucet_client.fund_account(alice.address(), alice_amount)
         print("Cuenta fondeada exitosamente")

         # Revisar balances iniciales
         alice_balance = await rest_client.account_balance(alice.address())
         bob_balance = await rest_client.account_balance(bob.address())

         print("\n=== Balances Iniciales ===")
         print(f"Alice: {alice_balance} octas")
         print(f"Bob: {bob_balance} octas")
         ```

      4. Correr el código

         Probemos nuestro código hasta ahora:

         ```shellscript filename="Terminal"
         python transaction.py
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Fondeando cuentas ===
         Cuenta fondeada exitosamente

         === Balances Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas
         ```

         <Aside type="note">
           Las direcciones que veas serán diferentes a las mostradas aquí, ya que se generan aleatoriamente cada vez.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 3. Construyendo una Transacción

<Tabs>
  <TabItem label="TypeScript">
    Ahora que tenemos cuentas fondeadas, vamos a crear una transacción para transferir coins de Alice a Bob. Esto es como llenar un formulario especificando qué quieres enviar y a quién.

    <Steps>
      1. Entender la estructura de la transacción

         Una transacción en Aptos tiene varios componentes clave:

         1. **Sender**: La cuenta que inicia la transacción (Alice)
         2. **Function**: La función on-chain a llamar (en este caso, una transferencia de coins)
         3. **Arguments**: Data necesaria por la función (dirección del recipiente y monto)
         4. **Gas parameters**: Cantidad máxima de gas (max gas amount) y precio por unidad de gas (gas unit price)
         5. **Expiration time**: Cuándo la transacción deja de ser válida si no se ha ejecutado
         6. **Sequence number**: Un contador que previene ataques de replay

         <Aside type="note">
           Toda la data en transacciones de Aptos se serializa usando Binary Canonical Serialization (BCS), un formato compacto y determinista diseñado para uso en blockchain. El SDK maneja esta serialización por ti.

           BCS asegura que la data de la transacción se codifique consistentemente a través de diferentes plataformas y lenguajes, lo cual es crítico para una blockchain donde la misma transacción podría ser procesada por nodos corriendo diferentes implementaciones.
         </Aside>

      2. Construir la transacción

         Vamos a agregar código para construir una transacción que transfiere 1000 octas de Alice a Bob:

         Agrega este código a tu función `main()`:

         ```typescript filename="transaction.ts"
         // 1. Construir la transacción
         console.log("\n=== 1. Construyendo la transacción ===");
         const transaction = await aptos.transaction.build.simple({
           sender: alice.accountAddress,
           data: {
             function: "0x1::aptos_account::transfer",
             functionArguments: [bob.accountAddress, 1000], // Transferir 1000 octas
           },
         });
         console.log("Transacción construida exitosamente");

         // Acceder a detalles de la transacción desde la raw transaction
         const rawTxn = transaction.rawTransaction;
         console.log(`Sender: ${rawTxn.sender}`);
         console.log(`Sequence Number: ${rawTxn.sequence_number}`);
         console.log(`Max Gas Amount: ${rawTxn.max_gas_amount}`);
         console.log(`Gas Unit Price: ${rawTxn.gas_unit_price}`);
         console.log(`Expiration Timestamp: ${new Date(Number(rawTxn.expiration_timestamp_secs) * 1000).toISOString()}`);
         ```

         <Aside type="note">
           La función `0x1::aptos_account::transfer` es una función built-in en el framework de Aptos que transfiere coins entre cuentas. El prefijo `0x1` indica que es parte del framework principal. Detrás de escena, esta función llama al [código fuente del módulo Coin Move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) para realizar la transferencia real.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Ahora que tenemos cuentas fondeadas, vamos a crear una transacción para transferir coins de Alice a Bob. Esto es como llenar un formulario especificando qué quieres enviar y a quién.

    <Steps>
      1. Entender la estructura de la transacción

         Una transacción en Aptos tiene varios componentes clave:

         1. **Sender**: La cuenta que inicia la transacción (Alice)
         2. **Function**: La función on-chain a llamar (en este caso, una transferencia de coins)
         3. **Arguments**: Data necesaria por la función (dirección del recipiente y monto)
         4. **Gas parameters**: Cantidad máxima de gas (max gas amount) y precio por unidad de gas (gas unit price)
         5. **Expiration time**: Cuándo la transacción deja de ser válida si no se ha ejecutado
         6. **Sequence number**: Un contador que previene ataques de replay

         <Aside type="note">
           Toda la data en transacciones de Aptos se serializa usando Binary Canonical Serialization (BCS), un formato compacto y determinista diseñado para uso en blockchain. El SDK maneja esta serialización por ti.

           BCS asegura que la data de la transacción se codifique consistentemente a través de diferentes plataformas y lenguajes, lo cual es crítico para una blockchain donde la misma transacción podría ser procesada por nodos corriendo diferentes implementaciones.
         </Aside>

      2. Construir la transacción

         Agrega el siguiente código a tu función `main()` para construir una transacción que transfiere 1000 octas de Alice a Bob:

         ```python filename="transaction.py"
         # 1. Construir la transacción
         print("\n=== 1. Construyendo la transacción ===")

         # Crear el payload de la entry function
         # Esto especifica qué función llamar y con qué argumentos
         entry_function = EntryFunction.natural(
             "0x1::aptos_account",  # Dirección y nombre del módulo
             "transfer",            # Nombre de la función
             [],                    # Argumentos de tipo (vacío para esta función)
             [
                 # Argumentos de función con su tipo de serialización
                 TransactionArgument(bob.address(), Serializer.struct),  # Dirección del recipiente
                 TransactionArgument(1000, Serializer.u64),              # Monto a transferir (1000 octas)
             ],
         )

         # Obtener el chain ID para la transacción
         chain_id = await rest_client.chain_id()

         # Obtener el sequence number actual del sender
         account_data = await rest_client.account(alice.address())
         sequence_number = int(account_data["sequence_number"])

         # Crear la raw transaction con todos los campos requeridos
         raw_transaction = RawTransaction(
             sender=alice.address(),                                    # Dirección del sender
             sequence_number=sequence_number,                           # Sequence number para prevenir ataques de replay
             payload=TransactionPayload(entry_function),                # La función a llamar
             max_gas_amount=2000,                                       # Unidades máximas de gas a usar
             gas_unit_price=100,                                        # Precio por unidad de gas en octas
             expiration_timestamps_secs=int(time.time()) + 600,         # Expira en 10 minutos
             chain_id=chain_id,                                         # Chain ID para asegurar la red correcta
         )

         print("Transacción construida exitosamente")
         print(f"Sender: {raw_transaction.sender}")
         print(f"Sequence Number: {raw_transaction.sequence_number}")
         print(f"Max Gas Amount: {raw_transaction.max_gas_amount}")
         print(f"Gas Unit Price: {raw_transaction.gas_unit_price}")
         print(f"Expiration Timestamp: {time.ctime(raw_transaction.expiration_timestamps_secs)}")
         ```

         <Aside type="note">
           La función `0x1::aptos_account::transfer` es una función built-in en el framework de Aptos que transfiere coins entre cuentas. El prefijo `0x1` indica que es parte del framework principal. Detrás de escena, esta función llama al [código fuente del módulo Coin Move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move) para realizar la transferencia real.

           El SDK de Python usa varios componentes clave para construir transacciones:

           - `EntryFunction.natural()` crea una referencia a una función Move ejecutable
           - `TransactionArgument` con tipos `Serializer` asegura la serialización BCS correcta
           - `TransactionPayload` envuelve la entry function para incluirla en la transacción
           - `RawTransaction` combina todos los parámetros en una transacción completa

           Este enfoque por capas te da un control granular sobre la construcción de la transacción.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 4. Simulando la Transacción

<Tabs>
  <TabItem label="TypeScript">
    Antes de hacer submit de una transacción, es una buena práctica simularla primero para estimar el costo del gas. Esto es como revisar los costos de envío antes de mandar un paquete.

    <Steps>
      1. Simular la transacción

         Agrega este código después de construir la transacción:

         ```typescript filename="transaction.ts"
         // 2. Simular la transacción
         console.log("\n=== 2. Simulando la transacción ===");
         const [simulationResult] = await aptos.transaction.simulate.simple({
           signerPublicKey: alice.publicKey,
           transaction,
         });

         const gasUsed = parseInt(simulationResult.gas_used);
         const gasUnitPrice = parseInt(simulationResult.gas_unit_price);
         console.log(`Unidades de gas estimadas: ${gasUsed}`);
         console.log(`Costo de gas estimado: ${gasUsed * gasUnitPrice} octas`);
         console.log(`La transacción sería ${simulationResult.success ? "exitosa" : "fallida"}`);
         ```

         <Aside type="note">
           El Gas es el fee computacional que se paga para procesar transacciones en la blockchain. El costo total se calcula como `gas_used × gas_unit_price`. Durante la simulación, la blockchain ejecuta la transacción en un entorno temporal para estimar estos costos sin hacer cambios permanentes al estado de la blockchain. Esto te ayuda a evitar transacciones fallidas por gas insuficiente.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Antes de hacer submit de una transacción, es una buena práctica simularla primero para estimar el costo del gas. Esto es como revisar los costos de envío antes de mandar un paquete.

    <Steps>
      1. Simular la transacción

         Agrega este código después de construir la transacción:

         ```python filename="transaction.py"
         # 2. Simular la transacción
         print("\n=== 2. Simulando la transacción ===")

         # Crear una transacción BCS para simulación
         # Esto realmente no hace submit de la transacción a la blockchain
         simulation_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(entry_function))

         # Simular la transacción para estimar costos de gas y revisar errores
         simulation_result = await rest_client.simulate_transaction(simulation_transaction, alice)

         # Extraer y mostrar los resultados de la simulación
         gas_used = int(simulation_result[0]['gas_used'])
         gas_unit_price = int(simulation_result[0]['gas_unit_price'])
         success = simulation_result[0]['success']

         print(f"Unidades de gas estimadas: {gas_used}")
         print(f"Costo de gas estimado: {gas_used * gas_unit_price} octas")
         print(f"La transacción sería {'exitosa' if success else 'fallida'}")
         ```

         <Aside type="note">
           El Gas es el fee computacional que se paga para procesar transacciones en la blockchain. El costo total se calcula como `gas_used × gas_unit_price`. Durante la simulación, la blockchain ejecuta la transacción en un entorno temporal para estimar estos costos sin hacer cambios permanentes al estado de la blockchain. Esto te ayuda a evitar transacciones fallidas por gas insuficiente.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 5. Firmando y haciendo Submit de la Transacción

<Tabs>
  <TabItem label="TypeScript">
    Ahora que hemos construido y simulado la transacción, necesitamos firmarla con la private key de Alice y hacerle submit a la blockchain.

    <Steps>
      1. Firmar la transacción

         La firma prueba que Alice autorizó esta transacción:

         Agrega este código después de simular la transacción:

         ```typescript filename="transaction.ts"
         // 3. Firmar la transacción
         console.log("\n=== 3. Firmando la transacción ===");
         const senderAuthenticator = aptos.transaction.sign({
           signer: alice,
           transaction,
         });
         console.log("Transacción firmada exitosamente");
         ```

         <Aside type="note">
           Las firmas digitales funcionan como un sello personal o firma en el mundo físico. Prueban que la transacción fue autorizada por el dueño de la cuenta (quien tiene la private key) y que no ha sido alterada.
         </Aside>

      2. Hacer submit de la transacción

         Agrega este código después de firmar la transacción para enviar la transacción firmada a la blockchain:

         ```typescript filename="transaction.ts"
         // 4. Hacer submit de la transacción
         console.log("\n=== 4. Haciendo submit de la transacción ===");
         const pendingTransaction = await aptos.transaction.submit.simple({
           transaction,
           senderAuthenticator,
         });
         console.log(`Transacción enviada con hash: ${pendingTransaction.hash}`);
         ```

         <Aside type="note">
           El hash de la transacción es un identificador único para tu transacción, similar a un número de rastreo de un paquete. Cuando haces submit de una transacción, la blockchain de Aptos realiza varias verificaciones de validación, incluyendo verificar la firma de la transacción y asegurar que el sequence number no haya sido usado antes (previniendo ataques de replay). Puedes usar el hash para revisar el estado de tu transacción en el [Aptos Explorer](https://explorer.aptoslabs.com/) o vía la [REST API](/es/build/apis/fullnode-rest-api).
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Ahora que hemos construido y simulado la transacción, necesitamos firmarla con la private key de Alice y hacerle submit a la blockchain.

    <Steps>
      1. Firmar la transacción

         La firma prueba que Alice autorizó esta transacción:

         Agrega este código después de simular la transacción:

         ```python filename="transaction.py"
         # 3. Firmar la transacción
         print("\n=== 3. Firmando la transacción ===")

         # Firmar la raw transaction con la private key del sender
         # Esto crea una firma criptográfica que prueba que el sender autorizó esta transacción
         signed_transaction = await rest_client.create_bcs_signed_transaction(
             alice,                                  # Cuenta con la private key
             TransactionPayload(entry_function),     # El payload de nuestra transacción
             sequence_number=sequence_number         # Usar el mismo sequence number de antes
         )

         print("Transacción firmada exitosamente")
         # No podemos extraer fácilmente la firma del objeto signed transaction,
         # pero podemos confirmar que fue creada
         ```

         <Aside type="note">
           Las firmas digitales funcionan como un sello personal o firma en el mundo físico. Prueban que la transacción fue autorizada por el dueño de la cuenta (quien tiene la private key) y que no ha sido alterada.
         </Aside>

      2. Hacer submit de la transacción

         Agrega este código después de firmar la transacción para enviar la transacción firmada a la blockchain:

         ```python filename="transaction.py"
         # 4. Hacer submit de la transacción
         print("\n=== 4. Haciendo submit de la transacción ===")

         # Hacer submit de la transacción firmada a la blockchain
         # Esto transmite la transacción a la red para ser procesada
         tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)

         print(f"Transacción enviada con hash: {tx_hash}")
         ```

         <Aside type="note">
           El hash de la transacción es un identificador único para tu transacción, similar a un número de rastreo de un paquete. Cuando haces submit de una transacción, la blockchain de Aptos realiza varias verificaciones de validación, incluyendo verificar la firma de la transacción y asegurar que el sequence number no haya sido usado antes (previniendo ataques de replay). Puedes usar el hash para revisar el estado de tu transacción en el [Aptos Explorer](https://explorer.aptoslabs.com/) o vía la [REST API](/es/build/apis/fullnode-rest-api).
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 6. Esperando Confirmación

<Tabs>
  <TabItem label="TypeScript">
    Después de hacer submit de una transacción, necesitamos esperar a que sea procesada por la blockchain. Esto es como esperar a que te entreguen el paquete.

    <Steps>
      1. Esperar a que se complete la transacción

         Agrega este código después de enviar la transacción:

         ```typescript filename="transaction.ts"
         // 5. Esperar a que la transacción se complete
         console.log("\n=== 5. Esperando a que se complete la transacción ===");
         const txnResult = await aptos.waitForTransaction({
           transactionHash: pendingTransaction.hash,
         });
         console.log(`Transacción completada con estado: ${txnResult.success ? "SUCCESS" : "FAILURE"}`);

         // Si quieres ver más detalles sobre la transacción:
         console.log(`VM Status: ${txnResult.vm_status}`);
         console.log(`Gas used: ${txnResult.gas_used}`);
         ```

      2. Verificar los resultados

         Agrega este código después de esperar a la transacción para revisar los balances y confirmar que la transferencia funcionó:

         ```typescript filename="transaction.ts"
         // Revisar balances finales
         const aliceFinalBalance = await aptos.getAccountAPTAmount({
           accountAddress: alice.accountAddress,
         });
         const bobFinalBalance = await aptos.getAccountAPTAmount({
           accountAddress: bob.accountAddress,
         });

         console.log("\n=== Balances Finales ===");
         console.log(`Alice: ${aliceFinalBalance} octas (gastó ${aliceBalance - aliceFinalBalance} octas en transferencia y gas)`);
         console.log(`Bob: ${bobFinalBalance} octas (recibió 1000 octas)`);
         ```

      3. Correr el código completo

         ```shellscript filename="Terminal"
         npx ts-node transaction.ts
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Fondeando cuentas ===
         Cuentas fondeadas exitosamente

         === Balances Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas

         === 1. Construyendo la transacción ===
         Transacción construida exitosamente
         Sender: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Sequence Number: 0
         Max Gas Amount: 20000
         Gas Unit Price: 100
         Expiration Timestamp: 2025-03-05T22:59:21.000Z

         === 2. Simulando la transacción ===
         Unidades de gas estimadas: 146
         Costo de gas estimado: 14600 octas
         La transacción sería exitosa

         === 3. Firmando la transacción ===
         Transacción firmada exitosamente

         === 4. Haciendo submit de la transacción ===
         Transacción enviada con hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

         === 5. Esperando a que se complete la transacción ===
         Transacción completada con estado: SUCCESS
         VM Status: Executed successfully
         Gas used: 146

         === Balances Finales ===
         Alice: 99984400 octas (gastó 15600 octas en transferencia y gas)
         Bob: 1000 octas (recibió 1000 octas)
         ```

         <Aside type="note">
           Nota que el balance de Alice disminuyó más de 1000 octas. La cantidad extra es el gas fee pagado para procesar la transacción. Detrás de escena, cuando se revisan los balances, el SDK consulta el recurso CoinStore para la AptosCoin (`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`) y lee el valor almacenado actual. Esto demuestra cómo el SDK abstrae interacciones complejas de blockchain en llamadas de función simples.
         </Aside>
    </Steps>
  </TabItem>

  <TabItem label="Python">
    Después de hacer submit de una transacción, necesitamos esperar a que sea procesada por la blockchain. Esto es como esperar a que te entreguen el paquete.

    <Steps>
      1. Esperar a que se complete la transacción

         Agrega este código después de enviar la transacción:

         ```python filename="transaction.py"
         # 5. Esperar a que se complete la transacción
         print("\n=== 5. Esperando a que se complete la transacción ===");

         # Esperar a que la transacción sea procesada por la blockchain
         # Esto hace polling a la blockchain hasta que la transacción sea confirmada
         await rest_client.wait_for_transaction(tx_hash)

         # Obtener los detalles de la transacción para revisar su estado
         transaction_details = await rest_client.transaction_by_hash(tx_hash)
         success = transaction_details["success"]
         vm_status = transaction_details["vm_status"]
         gas_used = transaction_details["gas_used"]

         print(f"Transacción completada con estado: {'SUCCESS' if success else 'FAILURE'}")
         print(f"VM Status: {vm_status}")
         print(f"Gas used: {gas_used}")
         ```

      2. Verificar los resultados

         Agrega este código después de esperar a la transacción para revisar los balances y confirmar que la transferencia funcionó:

         ```python filename="transaction.py"
         # Revisar balances finales
         alice_final_balance = await rest_client.account_balance(alice.address())
         bob_final_balance = await rest_client.account_balance(bob.address())

         print("\n=== Balances Finales ===")
         print(f"Alice: {alice_final_balance} octas (gastó {alice_balance - alice_final_balance} octas en transferencia y gas)")
         print(f"Bob: {bob_final_balance} octas (recibió 1000 octas)")
         ```

      3. Correr el código completo

         ```shellscript filename="Terminal"
         python transaction.py
         ```

         Deberías ver una salida similar a:

         ```
         Conectado a Aptos devnet
         === Direcciones ===
         Dirección de Alice: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Dirección de Bob: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

         === Fondeando cuentas ===
         Cuenta fondeada exitosamente

         === Balances Iniciales ===
         Alice: 100000000 octas
         Bob: 0 octas

         === 1. Construyendo la transacción ===
         Transacción construida exitosamente
         Sender: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
         Sequence Number: 0
         Max Gas Amount: 2000
         Gas Unit Price: 100
         Expiration Timestamp: Wed Mar 05 22:59:21 2025

         === 2. Simulando la transacción ===
         Unidades de gas estimadas: 146
         Costo de gas estimado: 14600 octas
         La transacción sería exitosa

         === 3. Firmando la transacción ===
         Transacción firmada exitosamente

         === 4. Haciendo submit de la transacción ===
         Transacción enviada con hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

         === 5. Esperando a que se complete la transacción ===
         Transacción completada con estado: SUCCESS
         VM Status: Executed successfully
         Gas used: 146

         === Balances Finales ===
         Alice: 99984400 octas (gastó 15600 octas en transferencia y gas)
         Bob: 1000 octas (recibió 1000 octas)
         ```

         <Aside type="note">
           Nota que el balance de Alice disminuyó más de 1000 octas. La cantidad extra es el gas fee pagado para procesar la transacción. Detrás de escena, cuando se revisan los balances, el SDK consulta el recurso CoinStore para la AptosCoin (`0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>`) y lee el valor almacenado actual.
         </Aside>
    </Steps>
  </TabItem>
</Tabs>

## 7. (Opcional) Explora tu Transacción On-Chain

Ahora que has ejecutado exitosamente una transacción, puedes explorarla en el Aptos Explorer. Esto te ayudará a entender cómo se registran las transacciones en la blockchain y qué información está disponible públicamente.

<Steps>
  1. Copia tu transaction hash

     Desde la salida de tu terminal, copia el hash de la transacción que se imprimió después del submit. Se ve algo así:

     ```
     Transacción enviada con hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc
     ```

  2. Abre el Aptos Explorer

     Ve al [Aptos Explorer](https://explorer.aptoslabs.com/?network=devnet).

  3. Asegúrate de estar en Devnet

     Busca "Devnet" en la esquina superior derecha, o cambia de red haciendo clic en el dropdown y seleccionando Devnet.

     ![Cambiando a la red Devnet en Aptos Explorer](~/images/screenshots/explorer_devnet.png)

  4. Busca tu transacción

     Pega tu transaction hash en la barra de búsqueda en el medio de la página.

     <Aside type="caution">
       ¡No presiones enter! Hay un bug conocido donde buscar con Enter no funciona.
     </Aside>

  5. Mira los detalles de la transacción

     Espera a que aparezcan los resultados, luego haz clic en el transaction hash para ver sus detalles.

     Deberías ver información sobre tu transacción, incluyendo:

     - Estado (debería ser "Success")
     - Timestamp
     - Gas used
     - Direcciones del sender y el recipiente
     - Monto transferido

  6. Explora más a fondo

     Desde la página de detalles de la transacción, puedes:

     - Hacer clic en las direcciones del sender o recipiente para ver los detalles de su cuenta
     - Ver los cambios exactos hechos al estado de la blockchain
     - Ver el payload de la transacción y los argumentos

     <Aside type="note">
       El Explorer es una herramienta poderosa para debugear transacciones y entender la actividad de la blockchain. Los developers frecuentemente lo usan para verificar que sus transacciones se ejecutaron como esperaban e investigar cualquier problema.
     </Aside>
</Steps>

## 8. Siguientes Pasos

¡Felicitaciones! Has creado y ejecutado exitosamente tu primera transacción en la blockchain de Aptos. Aquí hay algunas sugerencias para explorar a continuación:

**Aprende sobre transacciones más complejas**:

- [Firmas Multi-Agent](/es/build/sdks/ts-sdk/building-transactions/multi-agent-transactions) - Transacciones que requieren múltiples signers
- [Transacciones Patrocinadas](/es/build/sdks/ts-sdk/building-transactions/sponsoring-transactions) - Hacer que otra cuenta pague los gas fees
- [Batching de Transacciones](/es/build/sdks/ts-sdk/building-transactions/batching-transactions) - Enviar múltiples transacciones eficientemente

<Aside type="note">
  Los enlaces de arriba son para el SDK de TypeScript pero los principios son los mismos si estás usando Python o Rust.
</Aside>

**Explora smart contracts o conceptos básicos de cuentas**:

- [Tu Primer Módulo Move](/es/build/guides/first-move-module) - Crea tu propio smart contract
- [Conceptos Básicos de Cuentas](/es/network/blockchain/accounts)

¡[Únete al Discord de Aptos](https://discord.gg/aptoslabs) y comparte lo que estás construyendo!

## Full Code Sample

Los ejemplos de código completo abajo combinan todos los snippets que hemos cubierto en este tutorial:

<Tabs>
  <TabItem label="TypeScript">
    ```typescript filename="transaction.ts"
    import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

    async function main() {
      // Inicializar el cliente de Aptos
      const config = new AptosConfig({ network: Network.DEVNET });
      const aptos = new Aptos(config);

      console.log("Conectado a Aptos devnet");

      // Más código irá aquí
      // Generar dos cuentas
      const alice = Account.generate();
      const bob = Account.generate();

      console.log("=== Direcciones ===");
      console.log(`Dirección de Alice: ${alice.accountAddress}`);
      console.log(`Dirección de Bob: ${bob.accountAddress}`);

      // Fondear las cuentas con APT de prueba del faucet de devnet
      console.log("\n=== Fondeando cuentas ===");
      await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 100_000_000, // 1 APT = 100,000,000 octas
      });
      await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 0, // Bob empieza con 0 APT
      });
      console.log("Cuentas fondeadas exitosamente");

      // Revisar balances iniciales
      const aliceBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Balances Iniciales ===");
      console.log(`Alice: ${aliceBalance} octas`);
      console.log(`Bob: ${bobBalance} octas`);

      // 1. Construir la transacción
      console.log("\n=== 1. Construyendo la transacción ===");
      const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        data: {
          function: "0x1::aptos_account::transfer",
          functionArguments: [bob.accountAddress, 1000], // Transferir 1000 octas
        },
      });
      console.log("Transacción construida exitosamente");
      // Usar aserción de tipo para saltar el chequeo de tipos de TypeScript
      const txnAny = transaction as any;
      console.log(`Sender: ${alice.accountAddress}`); // Usar la dirección de sender conocida
      console.log(`Sequence Number: ${txnAny.sequenceNumber || "N/A"}`);
      console.log(`Max Gas Amount: ${txnAny.maxGasAmount || "N/A"}`);
      console.log(`Gas Unit Price: ${txnAny.gasUnitPrice || "N/A"}`);
      console.log(
        `Expiration Timestamp: ${new Date(
          Number(txnAny.expirationTimestampSecs || 0) * 1000
        ).toISOString()}`
      );

      // 2. Simular la transacción
      console.log("\n=== 2. Simulando la transacción ===");
      const [simulationResult] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        transaction,
      });

      console.log(`Unidades de gas estimadas: ${simulationResult.gas_used}`);
      console.log(
        `Costo de gas estimado: ${
          Number(simulationResult.gas_used) * Number(simulationResult.gas_unit_price)
        } octas`
      );
      console.log(
        `La transacción sería ${simulationResult.success ? "exitosa" : "fallida"}`
      );

      // 3. Firmar la transacción
      console.log("\n=== 3. Firmando la transacción ===");
      const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
      });
      console.log("Transacción firmada exitosamente");
      // Usar aserción de tipo para saltar el chequeo de tipos de TypeScript
      const authAny = senderAuthenticator as any;
      const signatureStr = typeof authAny.signature === 'string'
        ? authAny.signature
        : JSON.stringify(authAny.signature || '');
      console.log(`Signature: ${signatureStr.slice(0, 20)}...`);

      // 4. Hacer submit de la transacción
      console.log("\n=== 4. Haciendo submit de la transacción ===");
      const pendingTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
      });
      console.log(`Transacción enviada con hash: ${pendingTransaction.hash}`);

      // 5. Esperar a que la transacción se complete
      console.log("\n=== 5. Esperando a que se complete la transacción ===");
      const txnResult = await aptos.waitForTransaction({
        transactionHash: pendingTransaction.hash,
      });
      console.log(
        `Transacción completada con estado: ${
          txnResult.success ? "SUCCESS" : "FAILURE"
        }`
      );

      // Si quieres ver más detalles sobre la transacción:
      console.log(`VM Status: ${txnResult.vm_status}`);
      console.log(`Gas used: ${txnResult.gas_used}`);

      // Revisar balances finales
      const aliceFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: alice.accountAddress,
      });
      const bobFinalBalance = await aptos.getAccountAPTAmount({
        accountAddress: bob.accountAddress,
      });

      console.log("\n=== Balances Finales ===");
      console.log(
        `Alice: ${aliceFinalBalance} octas (gastó ${
          aliceBalance - aliceFinalBalance
        } octas en transferencia y gas)`
      );
      console.log(`Bob: ${bobFinalBalance} octas (recibió 1000 octas)`);
    }

    main().catch(console.error);
    ```
  </TabItem>

  <TabItem label="Python">
    ```python filename="transaction.py"
    import asyncio
    from aptos_sdk.account import Account
    from aptos_sdk.async_client import FaucetClient, RestClient
    from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument, RawTransaction
    from aptos_sdk.bcs import Serializer
    import time

    # Configuración de la red
    NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
    FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

    async def main():
        # Inicializar los clientes
        rest_client = RestClient(NODE_URL)
        faucet_client = FaucetClient(FAUCET_URL, rest_client)

        print("Conectado a Aptos devnet")

        # Generar dos cuentas
        alice = Account.generate()
        bob = Account.generate()

        print("=== Direcciones ===");
        print(f"Dirección de Alice: {alice.address()}")
        print(f"Dirección de Bob: {bob.address()}")
            # Más código irá aquí
            # Fondear las cuentas con APT de prueba del faucet de devnet
        print("\n=== Fondeando cuentas ===");
        alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
        bob_amount = 0  # Bob empieza con 0 APT

        await faucet_client.fund_account(alice.address(), alice_amount)
        await faucet_client.fund_account(bob.address(), bob_amount)
        print("Cuentas fondeadas exitosamente");

        # Revisar balances iniciales
        alice_balance = await rest_client.account_balance(alice.address())
        bob_balance = await rest_client.account_balance(bob.address())

        print("\n=== Balances Iniciales ===");
        print(f"Alice: {alice_balance} octas")
        print(f"Bob: {bob_balance} octas")

        # 1. Construir la transacción
        print("\n=== 1. Construyendo la transacción ===")

        # Crear el payload de la entry function
        # Esto especifica qué función llamar y con qué argumentos
        entry_function = EntryFunction.natural(
            "0x1::aptos_account",  # Dirección y nombre del módulo
            "transfer",            # Nombre de la función
            [],                    # Argumentos de tipo (vacío para esta función)
            [
                # Argumentos de función con su tipo de serialización
                TransactionArgument(bob.address(), Serializer.struct),  # Dirección del recipiente
                TransactionArgument(1000, Serializer.u64),              # Monto a transferir (1000 octas)
            ],
        )

        # Obtener el chain ID para la transacción
        chain_id = await rest_client.chain_id()

        # Obtener el sequence number actual del sender
        account_data = await rest_client.account(alice.address())
        sequence_number = int(account_data["sequence_number"])

        # Crear la raw transaction con todos los campos requeridos
        raw_transaction = RawTransaction(
            sender=alice.address(),                                    # Dirección del sender
            sequence_number=sequence_number,                           # Sequence number para prevenir ataques de replay
            payload=TransactionPayload(entry_function),                # La función a llamar
            max_gas_amount=2000,                                       # Unidades máximas de gas a usar
            gas_unit_price=100,                                        # Precio por unidad de gas en octas
            expiration_timestamps_secs=int(time.time()) + 600,         # Expira en 10 minutos
            chain_id=chain_id,                                         # Chain ID para asegurar la red correcta
        )

        print("Transacción construida exitosamente")
        print(f"Sender: {raw_transaction.sender}")
        print(f"Sequence Number: {raw_transaction.sequence_number}")
        print(f"Max Gas Amount: {raw_transaction.max_gas_amount}")
        print(f"Gas Unit Price: {raw_transaction.gas_unit_price}")
        print(f"Expiration Timestamp: {time.ctime(raw_transaction.expiration_timestamps_secs)}")

        # 2. Simular la transacción
        print("\n=== 2. Simulando la transacción ===")

        # Crear una transacción BCS para simulación
        # Esto realmente no hace submit de la transacción a la blockchain
        simulation_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(entry_function))

        # Simular la transacción para estimar costos de gas y revisar errores
        simulation_result = await rest_client.simulate_transaction(simulation_transaction, alice)

        # Extraer y mostrar los resultados de la simulación
        gas_used = int(simulation_result[0]['gas_used'])
        gas_unit_price = int(simulation_result[0]['gas_unit_price'])
        success = simulation_result[0]['success']

        print(f"Unidades de gas estimadas: {gas_used}")
        print(f"Costo de gas estimado: {gas_used * gas_unit_price} octas")
        print(f"La transacción sería {'exitosa' if success else 'fallida'}")

        # 3. Firmar la transacción
        print("\n=== 3. Firmando la transacción ===")

        # Firmar la raw transaction con la private key del sender
        # Esto crea una firma criptográfica que prueba que el sender autorizó esta transacción
        signed_transaction = await rest_client.create_bcs_signed_transaction(
            alice,                                  # Cuenta con la private key
            TransactionPayload(entry_function),     # El payload de nuestra transacción
            sequence_number=sequence_number         # Usar el mismo sequence number de antes
        )

        print("Transacción firmada exitosamente")
        # No podemos extraer fácilmente la firma del objeto signed transaction,
        # pero podemos confirmar que fue creada

        # 4. Hacer submit de la transacción
        print("\n=== 4. Haciendo submit de la transacción ===");

        # Hacer submit de la transacción firmada a la blockchain
        # Esto transmite la transacción a la red para ser procesada
        tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)

        print(f"Transacción enviada con hash: {tx_hash}")

        # 5. Esperar a que se complete la transacción
        print("\n=== 5. Esperando a que se complete la transacción ===");

        # Esperar a que la transacción sea procesada por la blockchain
        # Esto hace polling a la blockchain hasta que la transacción sea confirmada
        await rest_client.wait_for_transaction(tx_hash)

        # Obtener los detalles de la transacción para revisar su estado
        transaction_details = await rest_client.transaction_by_hash(tx_hash)
        success = transaction_details["success"]
        vm_status = transaction_details["vm_status"]
        gas_used = transaction_details["gas_used"]

        print(f"Transacción completada con estado: {'SUCCESS' if success else 'FAILURE'}")
        print(f"VM Status: {vm_status}")
        print(f"Gas used: {gas_used}")

        # Revisar balances finales
        alice_final_balance = await rest_client.account_balance(alice.address())
        bob_final_balance = await rest_client.account_balance(bob.address())

        print("\n=== Balances Finales ===");
        print(f"Alice: {alice_final_balance} octas (gastó {alice_balance - alice_final_balance} octas en transferencia y gas)")
        print(f"Bob: {bob_final_balance} octas (recibió 1000 octas)")
    if __name__ == "__main__":
        asyncio.run(main())
    ```
  </TabItem>
</Tabs>
