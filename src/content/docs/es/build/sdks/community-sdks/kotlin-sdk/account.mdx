---
title: "Crear y Gestionar Cuentas"
description: "Crea y gestiona cuentas legacy, SingleKey y MultiKey con el SDK Kotlin de Kaptos"
sidebar:
  label: "Cuentas"
---

Kaptos soporta tres patrones de cuenta importantes para producción:

- **Cuenta legacy Ed25519** (`Ed25519Account` / `Account.generate()` por defecto)
- **Cuenta SingleKey** (`SingleKeyAccount`) con auth key unificada
- **Cuenta MultiKey** (`MultiKeyAccount`) para firmas por umbral

## Cuenta legacy (Ed25519)

La ruta por defecto `Account.generate()` crea una cuenta legacy Ed25519.

```kotlin
val legacy = Account.generate()

val explicitLegacy = Account.generate(
  scheme = SigningSchemeInput.Ed25519,
  legacy = true,
)
```

También puedes derivar una cuenta legacy desde una clave privada Ed25519 existente:

```kotlin
val legacyFromPrivateKey =
  Account.fromPrivateKey(
    Ed25519PrivateKey("0x...")
  )
```

## Cuenta SingleKey (Ed25519 o Secp256k1)

Usa `SingleKeyAccount` cuando necesitas autenticación unificada y flexibilidad de esquema.

```kotlin
val ed25519Single = SingleKeyAccount.generate(SigningSchemeInput.Ed25519)
val secp256k1Single = SingleKeyAccount.generate(SigningSchemeInput.Secp256k1)
```

También puedes pedir una cuenta single-key vía `Account.generate(...)`:

```kotlin
val singleViaAccount = Account.generate(
  scheme = SigningSchemeInput.Ed25519,
  legacy = false,
)
```

Para derivar desde claves privadas existentes:

```kotlin
val ed25519SingleFromPrivateKey =
  SingleKeyAccount(
    Ed25519PrivateKey("0x...")
  )

val secp256k1SingleFromPrivateKey =
  SingleKeyAccount(
    Secp256k1PrivateKey(HexInput.fromString("0x..."))
  )
```

## Cuenta MultiKey (firma por umbral)

`MultiKeyAccount` te permite definir una identidad de firma por umbral desde varias claves públicas.

```kotlin
val signerA = SingleKeyAccount.generate(SigningSchemeInput.Ed25519)
val signerB = SingleKeyAccount.generate(SigningSchemeInput.Secp256k1)
val signerC = SingleKeyAccount.generate(SigningSchemeInput.Ed25519)

val multiKeyAccount =
  MultiKeyAccount.fromPublicKeysAndSigners(
    publicKeys = listOf(signerA.publicKey, signerB.publicKey, signerC.publicKey),
    signaturesRequired = 2,
    signers = listOf(signerA, signerC),
  )
```

En la API actual, `signers.size` debe coincidir con `signaturesRequired`.

Como `MultiKeyAccount` extiende `Account`, puede firmar transacciones igual que otros tipos de cuenta:

```kotlin
val txn =
  aptos.buildSimpleTransaction(sender = multiKeyAccount.accountAddress) {
    function = "0x1::coin::transfer"
    typeArgs("0x1::aptos_coin::AptosCoin")
    args(Account.generate().accountAddress, 1_000_000UL)
  }

val pending = aptos.signAndSubmitTransaction(multiKeyAccount, txn)
```

## Creación de cuenta on-chain

Generar una cuenta solo crea credenciales locales. La dirección no existe en cadena hasta que la financias/creas.

```kotlin
aptos
  .fundAccount(accountAddress = legacy.accountAddress, amount = 100_000_000L)
  .expect("Failed to fund account")
```

En testnet también puedes usar la [página del faucet](/es/network/faucet).
