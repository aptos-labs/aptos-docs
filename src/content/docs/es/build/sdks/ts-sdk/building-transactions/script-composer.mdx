---
title: "Invocar cadenas de llamadas Move con el Compositor de Scripts Dinámico"
---

import { Aside } from '@astrojs/starlight/components';

<Aside type="tip">
  ¡Nos complace anunciar que ahora contamos con un paquete independiente para la funcionalidad de Script Composer, disponible en el siguiente repositorio:

  https://github.com/aptos-labs/script-composer-sdk

  ¡Por supuesto! También puedes usarlo como un paquete de npm. Instálalo aquí:

  https://www.npmjs.com/package/@aptos-labs/script-composer-sdk
</Aside>

<Aside type="caution">
  Si aún estás usando Script Composer en la versión 1.39.0 del ts-sdk, cambia a la versión del paquete independiente lo antes posible:
  [https://www.npmjs.com/package/@aptos-labs/ts-sdk/v/1.39.0](https://www.npmjs.com/package/@aptos-labs/ts-sdk/v/1.39.0)
</Aside>

En la API básica solo puedes especificar una llamada a función de entrada por transacción. Los constructores avanzados pueden querer invocar múltiples funciones **públicas** de Move en una sola transacción. Esto ahora es posible con la nueva API `scriptComposer` del generador de transacciones.

Aquí tienes un ejemplo de uso actualizado con el paquete independiente:

```typescript filename="example.ts"
const tx = await BuildScriptComposerTransaction({
  // Dirección del remitente
  sender: singleSignerED25519SenderAccount.accountAddress,
  builder: async (composer) => {
    // 1) Retira algunas monedas
    const coin = await composer.addBatchedCalls({
      function: "0x1::coin::withdraw",
      functionArguments: [CallArgument.newSigner(0), 1],
      typeArguments: ["0x1::aptos_coin::AptosCoin"],
    });

    // 2) Convierte Coin -> Fungible Asset
    const fungibleAsset = await composer.addBatchedCalls({
      function: "0x1::coin::coin_to_fungible_asset",
      functionArguments: [coin[0]], // primer valor de retorno
      typeArguments: ["0x1::aptos_coin::AptosCoin"],
    });

    // 3) Deposita el FA en el Primary Fungible Store
    await composer.addBatchedCalls({
      function: "0x1::primary_fungible_store::deposit",
      functionArguments: [singleSignerED25519SenderAccount.accountAddress, fungibleAsset[0]],
      typeArguments: [],
    });
    return composer;
  },
  // Se requiere AptosConfig porque la transacción compuesta lee estado on-chain
  aptosConfig: new AptosConfig({ network: Network.TESTNET }),
});
```

Detrás de escena, el SDK invoca un binario WASM para compilar la serie de llamadas Move en un `CompiledScript`. Esto garantiza que la seguridad de tipos y habilidades de Move se respete durante la construcción. Para los usuarios del SDK, esto significa:

1. seguridad de habilidades:
   a. Si el valor devuelto no tiene la habilidad Drop, el valor devuelto necesita ser consumido por llamadas posteriores.
   b. Si el valor devuelto no tiene la habilidad Copy, el valor devuelto solo puede ser pasado a llamadas posteriores una vez.
2. El llamador necesitará asegurarse de que pase los valores correctos como argumentos a llamadas posteriores. En el ejemplo anterior, `0x1::coin::coin_to_fungible_asset` esperará un argumento de `Coin<AptosCoin>`.

Esto implementa [AIP-102](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-102.md)
