---
title: "Comparación"
description: "Entiende las operaciones de comparación y su semántica en el lenguaje de programación Move."
sidebar:
  label: "Comparación"
---

Move soporta cuatro operaciones de comparación `<`, `>`, `<=`, y `>=`.

## Operaciones

| Sintaxis | Operación         |
| -------- | ----------------- |
| `<`      | menor que         |
| `>`      | mayor que         |
| `<=`     | menor o igual que |
| `>=`     | mayor o igual que |

### Tipado

Las operaciones de comparación solo funcionan si ambos operandos tienen el mismo tipo.

```move
script {
  fun example() {
    0 >= 0; // `true`
    1u128 > 2u128; // `false`
  }
}
```

Si los operandos tienen tipos diferentes, hay un error de verificación de tipos.

```move
script {
  fun example() {
    1u8 >= 1u128; // ¡ERROR!
    //     ^^^^^ se esperaba un argumento de tipo `u8`
  }
}
```

Antes de la versión de lenguaje 2.2, las operaciones de comparación solo funcionaban con tipos enteros. _Desde la versión de lenguaje 2.2_, las operaciones de comparación funcionan con todos los tipos.

| Tipo          | Semántica                                                                                                                                    |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| entero        | comparar por el valor numérico                                                                                                               |
| `bool`        | `true` siendo mayor que `false`                                                                                                              |
| `address`     | comparar como enteros sin signo de 256 bits                                                                                                  |
| `signer`      | comparar por la `address` envuelta por el `signer`                                                                                           |
| `struct`      | comparar por valores de campo primero, y luego por el número de campos.                                                                      |
| `vector`      | comparar por valores de elementos primero, y luego por el número de elementos                                                                |
| valor función | comparar en orden por dirección del módulo, nombre del módulo, nombre de función, lista de tipos de argumentos y lista de valores capturados |
| referencia    | comparar por el valor al que se hace referencia                                                                                              |

```move
module 0x42::example {
    struct S has copy, drop { f: u64, s: vector<u8> }

    fun true_example(): bool {
        let s1 = S { f: 0, s: b"" };
        let s2 = S { f: 1, s: b"" };
        // retorna true
        s1 < s2
    }

    fun false_example(): bool {
        let s1 = S { f: 0, s: b"abc" };
        let s2 = S { f: 0, s: b"" };
        // retorna false
        s1 < s2
    }
}
```

### Tipado con referencias

Cuando se comparan [referencias](/es/build/smart-contracts/book/references), se comparan los valores a los que hacen referencia. El tipo de la referencia (inmutable o mutable) no importa. Esto significa que puedes comparar una referencia inmutable `&` con una mutable `&mut` del mismo tipo subyacente.

```move
script {
  fun example() {
    let i = &0u64;
    let m = &mut 1u64;

    i > m; // `false`
    m < i; // `false`
    m >= m; // `true`
    i <= i; // `true`
  }
}
```

Lo anterior es equivalente a aplicar un freeze explícito a cada referencia mutable donde sea necesario

```move
script {
  fun example() {
    let i = &0u64;
    let m = &mut 1u64;

    i > freeze(m); // `false`
    freeze(m) < i; // `false`
    m >= m; // `true`
    i <= i; // `true`
  }
}
```

Pero de nuevo, el tipo subyacente debe ser el mismo.

```move
script {
  fun example() {
    let i = &0u64;
    let s = &b"";

    i > s; // ¡ERROR!
    //   ^ se esperaba un argumento de tipo '&u64'
  }
}
```

## Comparación con `==` y `!=`

Las operaciones de comparación consumen operandos para enteros pero los toman prestados automáticamente para tipos no enteros.
Esto difiere de las operaciones de [igualdad `==` y desigualdad `!=`](/es/build/smart-contracts/book/equality#restrictions), que siempre consumen sus operandos y requieren la [habilidad `drop`](/es/build/smart-contracts/book/abilities).

```move
module 0x42::example {
  struct Coin has store { value: u64 }
  fun invalid(c1: Coin, c2: Coin) {
    c1 <= c2 // ¡OK!
    c1 == c2 // ¡ERROR!
//  ^^    ^^ ¡Estos recursos serían destruidos!
  }
}
```
