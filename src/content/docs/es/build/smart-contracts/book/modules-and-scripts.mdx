---
title: "Módulos y Scripts"
description: "Aprende sobre módulos y scripts en el lenguaje de programación Move para el desarrollo de contratos inteligentes en Aptos."
sidebar:
  label: "Módulos y Scripts"
---

import { Aside } from '@astrojs/starlight/components';

Move tiene dos tipos diferentes de programas: **_Módulos_** y **_Scripts_**. Los módulos son bibliotecas que definen tipos struct junto con funciones que operan sobre estos tipos. Los tipos struct definen el esquema del [almacenamiento global](/es/build/smart-contracts/book/global-storage-structure) de Move, y las funciones del módulo definen las reglas para actualizar el almacenamiento. Los módulos en sí también se almacenan en el almacenamiento global. Un script es un punto de entrada ejecutable similar a una función `main` en un lenguaje convencional. Un script típicamente llama funciones de un módulo publicado que realizan actualizaciones al almacenamiento global. Los scripts son fragmentos de código efímeros que no se publican en el almacenamiento global.

Un archivo fuente de Move (o **unidad de compilación**) puede contener múltiples módulos y scripts. Sin embargo, publicar un módulo o ejecutar un script son operaciones separadas de la VM.

## Sintaxis

### Scripts

<Aside type="note">
  Para aprender cómo publicar y ejecutar un script de Move, sigue el ejemplo de [Scripts de Move](/es/build/smart-contracts/scripts/script-tutorial).
</Aside>

Un script tiene la siguiente estructura:

```text
script {
    <use>*
    <constants>*
    fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>
}
```

Un bloque `script` debe comenzar con todas sus declaraciones [`use`](/es/build/smart-contracts/book/uses), seguido por cualquier [constante](/es/build/smart-contracts/book/constants) y (finalmente) la declaración de la [función](/es/build/smart-contracts/book/functions) principal.
La función principal puede tener cualquier nombre (es decir, no necesita llamarse `main`), es la única función en un bloque script, puede tener cualquier número de argumentos, y no debe devolver un valor. Aquí hay un ejemplo con cada uno de estos componentes:

```move
script {
    // Importar el módulo debug publicado en la dirección de cuenta nombrada std.
    use std::debug;

    const ONE: u64 = 1;

    fun main(x: u64) {
        let sum = x + ONE;
        debug::print(&sum)
    }
}
```

Los scripts tienen poder muy limitado: no pueden declarar friends, tipos struct o acceder al almacenamiento global. Su propósito principal es invocar funciones de módulos.

### Módulos

Un módulo tiene la siguiente sintaxis:

```move
module <address>::<identifier> {
    (<use> | <friend> | <type> | <function> | <constant>)*
}
```

donde `<address>` es una [dirección nombrada o literal](/es/build/smart-contracts/book/address) válida.

Por ejemplo:

```move
module 0x42::example {
    struct Example has copy, drop { i: u64 }

    use std::debug;
    friend 0x42::another_example;

    const ONE: u64 = 1;

    public fun print(x: u64) {
        let sum = x + ONE;
        let example = Example { i: sum };
        debug::print(&sum)
    }
}
```

El `module 0x42::example` parte especifica que el módulo `example` se publicará bajo la [dirección de cuenta](/es/build/smart-contracts/book/address) `0x42` en el [almacenamiento global](/es/build/smart-contracts/book/global-storage-structure).

Los módulos también pueden usar direcciones nombradas. Por ejemplo:

```move
module my_addr::example {
    struct Example has copy, drop { a: address }

    use std::debug;
    friend my_addr::another_example;

    public fun print() {
        let example = Example { a: @my_addr };
        debug::print(&example)
    }
}
```

Debido a que las direcciones nombradas solo existen en el nivel de compilación y durante la compilación, las direcciones nombradas se sustituirán completamente por su valor.

Los módulos no tienen una función `main`. En su lugar, las funciones del módulo se invocan por scripts o por otros módulos.

## Nombres

Los módulos y scripts son ambos tipos de unidades de nivel superior, y ambos se ubican en el nivel superior de un archivo fuente. Un módulo también define el espacio de nombres para los tipos y funciones que declara.

Los nombres de módulos y scripts deben comenzar con una letra minúscula `a` a `z` o una letra mayúscula `A` a `Z`. Después del primer carácter, los nombres de módulos y scripts pueden contener guiones bajos `_`, letras `a` a `z`, letras `A` a `Z`, o dígitos `0` a `9`.

```move
module my_module {}
module foo_bar_42 {}
```

Típicamente, los nombres de módulos comienzan con una letra minúscula. Un módulo nombrado `my_module` debe ser almacenado en un archivo fuente nombrado `my_module.move`.

Todos los elementos dentro de un módulo pueden referirse entre sí sin ningún calificación. En particular, los tipos declarados dentro de un módulo no necesitan ser prefijados con el nombre del módulo.

```move
module 0x42::example {
    struct Example has copy, drop { i: u64 }

    fun make_example(): Example {
        Example { i: 1 } // Note: no hay necesidad de 0x42::example::Example
    }
}
```

En el ejemplo anterior, `make_example` puede referirse al tipo `Example` sin calificación ya que ambos están en el mismo módulo.

## Direcciones de Módulos

Cuando un módulo se publica, se publica bajo una cuenta específica en el almacenamiento global a una [dirección](/es/build/smart-contracts/book/address).

La dirección donde se publica un módulo es llamada la dirección del módulo. Por ejemplo, el módulo estándar `vector` se publica bajo la dirección `0x1`. Si quisieras usar el módulo `vector` fuera del módulo `std` (la biblioteca estándar), necesitarías accederlo a través de esa dirección: `0x1::vector`.

Sin embargo, esto puede volverse verboso. Las declaraciones [`use`](/es/build/smart-contracts/book/uses) permiten un acceso más corto a módulos sin tener que deletrear la dirección completa cada vez.

## Convenciones de Nomenclatura

Si bien puedes nombrar un módulo cualquier cosa que quieras, aquí hay algunas convenciones comunes:

- Los nombres de módulos deben estar en snake\_case: `my_module`, `user_account`
- Los nombres de módulos deben usar sustantivos que describan lo que contiene el módulo
- Si un módulo define un único tipo principal, el módulo generalmente se nombra igual que ese tipo: `module coin` para `struct Coin`
