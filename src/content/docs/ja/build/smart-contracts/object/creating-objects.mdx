---
title: "オブジェクトの作成"
---

import { Aside } from '@astrojs/starlight/components';

オブジェクトの作成には2つのステップがあります:

1. `ObjectCore`リソースグループの作成(後でオブジェクトを参照するために使用できるアドレスを持ちます).
2. `Ref`と呼ばれる権限を使用してオブジェクトの動作をカスタマイズします.

<Aside type="note">
  `Ref`を生成してオブジェクトを設定することは,オブジェクトを作成するのと同じトランザクションで行う必要があります.
  後でこれらの設定を変更することはできません.
</Aside>

## オブジェクトの作成

作成できるオブジェクトには3つのタイプがあります:

1. **通常のオブジェクト.** このタイプは削除可能でランダムなアドレスを持ちます.以下を使用して作成できます:`0x1::object::create_object(owner_address: address)`.例:

```move filename="object_playground.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object;

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);
    let constructor_ref = object::create_object(caller_address);
    // ...
  }
}
```

2. **名前付きオブジェクト.** このタイプは削除**不可能**で,決定論的なアドレスを持ちます.以下を使用して作成できます:`0x1::object::create_named_object(creator: &signer, seed: vector<u8>)`.例:

```move filename="object_playground.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object;

  /// Seed for my named object, must be globally unique to the creating account
  const NAME: vector<u8> = b"MyAwesomeObject";

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);
    let constructor_ref = object::create_named_object(caller, NAME);
    // ...
  }

  #[view]
  fun has_object(creator: address): bool {
    let object_address = object::create_object_address(&creator, NAME);
    object::object_exists<0x1::object::ObjectCore>(object_address)
  }
}
```

3. **スティッキーオブジェクト.** このタイプも削除**不可能**で,ランダムなアドレスを持ちます.以下を使用して作成できます:`0x1::object::create_sticky_object(owner_address: address)`.例:

```move filename="object_playground.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object;

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);
    let constructor_ref = object::create_sticky_object(caller_address);
    // ...
  }
}
```

## オブジェクト機能のカスタマイズ

オブジェクトを作成すると,追加の`Ref`を生成するために使用できる`ConstructorRef`を受け取ります.`Ref`は,リソースの転送,オブジェクト自体の転送,オブジェクトの削除など,特定のオブジェクト機能を有効化/無効化/実行するために将来使用できます.

以下のセクションでは,一般的に使用される`Ref`とそれらが有効にする機能について説明します.

<Aside type="note">
  注意:`ConstructorRef`は保存できません.オブジェクトを作成するために使用されたトランザクションの終了時に破棄されるため,
  他の`Ref`は必ずオブジェクト作成時に生成する必要があります.
</Aside>

### リソースの追加

`ConstructorRef`を`object::generate_signer`と共に使用して,オブジェクトにリソースを転送できるsignerを作成できます.これは,アカウントにリソースを追加する場合と同じ`move_to`関数を使用します.

```move filename="Example.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object;

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct MyStruct has key {
    num: u8
  }

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);

    // Creates the object
    let constructor_ref = object::create_object(caller_address);

    // Retrieves a signer for the object
    let object_signer = object::generate_signer(&constructor_ref);

    // Moves the MyStruct resource into the object
    move_to(&object_signer, MyStruct { num: 0 });

    // ...
  }
}
```

### 拡張性の追加(`ExtendRef`)

時にはオブジェクトを後で編集可能にしたい場合があります.その場合,`object::generate_extend_ref`を使用して`ExtendRef`を生成できます.このrefはオブジェクトのsignerを生成するために使用できます.

以下の例のように,スマートコントラクトのロジックを通じて`ExtendRef`の使用権限を制御できます.

```move filename="Example.move"
module my_addr::object_playground {
  use std::signer;
  use std::string::{Self, String};
  use aptos_framework::object::{Self, Object};

  /// Caller is not the owner of the object
  const E_NOT_OWNER: u64 = 1;
  /// Caller is not the publisher of the contract
  const E_NOT_PUBLISHER: u64 = 2;

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct MyStruct has key {
    num: u8
  }

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct Message has key {
    message: string::String
  }

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct ObjectController has key {
    extend_ref: object::ExtendRef,
  }

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);

    // Creates the object
    let constructor_ref = object::create_object(caller_address);

    // Retrieves a signer for the object
    let object_signer = object::generate_signer(&constructor_ref);

    // Moves the MyStruct resource into the object
    move_to(&object_signer, MyStruct { num: 0 });

    // Creates an extend ref, and moves it to the object
    let extend_ref = object::generate_extend_ref(&constructor_ref);
    move_to(&object_signer, ObjectController { extend_ref });
    // ...
  }

  entry fun add_message(
    caller: &signer,
    object: Object<MyStruct>,
    message: String
  ) acquires ObjectController {
    let caller_address = signer::address_of(caller);
    // There are a couple ways to go about permissions

    // Allow only the owner of the object
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
    // Allow only the publisher of the contract
    assert!(caller_address == @my_addr, E_NOT_PUBLISHER);
    // Or any other permission scheme you can think of, the possibilities are endless!

    // Use the extend ref to get a signer
    let object_address = object::object_address(&object);
    let extend_ref = &borrow_global<ObjectController>(object_address).extend_ref;
    let object_signer = object::generate_signer_for_extending(extend_ref);

    // Extend the object to have a message
    move_to(&object_signer, Message { message });
  }
}
```

### 転送の無効化/切り替え(`TransferRef`)

デフォルトでは,すべてのオブジェクトは転送可能です.これは`object::generate_transfer_ref`を使用して生成できる`TransferRef`を通じて変更できます.

以下の例は,オブジェクトが転送可能かどうかを決定するための権限を生成および管理する方法を示しています.

```move filename="Example.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object::{Self, Object};

  /// Caller is not the publisher of the contract
  const E_NOT_PUBLISHER: u64 = 1;

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct ObjectController has key {
    transfer_ref: object::TransferRef,
  }

  entry fun create_my_object(
    caller: &signer,
    transferrable: bool,
    controllable: bool
  ) {
    let caller_address = signer::address_of(caller);

    // Creates the object
    let constructor_ref = object::create_object(caller_address);

    // Retrieves a signer for the object
    let object_signer = object::generate_signer(&constructor_ref);

    // Creates a transfer ref for controlling transfers
    let transfer_ref = object::generate_transfer_ref(&constructor_ref);

    // We now have a choice, we can make it so the object can be transferred
    // and we can decide if we want to allow it to change later.  By default, it
    // is transferrable
    if (!transferrable) {
      object::disable_ungated_transfer(&transfer_ref);
    };

    // If we want it to be controllable, we must store the transfer ref for later
    if (controllable) {
      move_to(&object_signer, ObjectController { transfer_ref });
    }
    // ...
  }

  /// In this example, we'll only let the publisher of the contract change the
  /// permissions of transferring
  entry fun toggle_transfer(
    caller: &signer,
    object: Object<ObjectController>
  ) acquires ObjectController {
    // Only let the publisher toggle transfers
    let caller_address = signer::address_of(caller);
    assert!(caller_address == @my_addr, E_NOT_PUBLISHER);

    // Retrieve the transfer ref
    let object_address = object::object_address(&object);
    let transfer_ref = &borrow_global<ObjectController>(
      object_address
    ).transfer_ref;

    // Toggle it based on its current state
    if (object::ungated_transfer_allowed(object)) {
      object::disable_ungated_transfer(transfer_ref);
    } else {
      object::enable_ungated_transfer(transfer_ref);
    }
  }
}
```

### 一回限りの転送(`LinearTransferRef`)

さらに,作成者がすべての転送を制御したい場合,`TransferRef`から`LinearTransferRef`を作成して,一回限りの転送機能を提供できます.これは,オブジェクト作成者から受信者への一回限りの転送によって&quot;ソウルバウンド&quot;オブジェクトを作成するために使用できます.`LinearTransferRef`はオブジェクトの所有者が使用する必要があります.

```move filename="Example.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object::{Self, Object};

  /// Caller is not the publisher of the contract
  const E_NOT_PUBLISHER: u64 = 1;

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct ObjectController has key {
    transfer_ref: object::TransferRef,
  }

  entry fun create_my_object(
    caller: &signer,
  ) {
    let caller_address = signer::address_of(caller);

    // Creates the object
    let constructor_ref = object::create_object(caller_address);

    // Retrieves a signer for the object
    let object_signer = object::generate_signer(&constructor_ref);

    // Creates a transfer ref for controlling transfers
    let transfer_ref = object::generate_transfer_ref(&constructor_ref);

    // Disable ungated transfer
    object::disable_ungated_transfer(&transfer_ref);
    move_to(&object_signer, ObjectController {
      transfer_ref,
    });
    // ...
  }

  /// In this example, we'll only let the publisher of the contract change the
  /// permissions of transferring
  /// Now only owner can transfer exactly once
  entry fun transfer(
    caller: &signer,
    object: Object<ObjectController>,
    new_owner: address
  ) acquires ObjectController {
    // Only let the publisher toggle transfers
    let caller_address = signer::address_of(caller);
    assert!(caller_address == @my_addr, E_NOT_PUBLISHER);

    let object_address = object::object_address(&object);

    // Retrieve the transfer ref
    let transfer_ref = &borrow_global<ObjectController>(
      object_address
    ).transfer_ref;

    // Generate a one time use `LinearTransferRef`
    let linear_transfer_ref = object::generate_linear_transfer_ref(
      transfer_ref
    );

    object::transfer_with_ref(linear_transfer_ref, new_owner);
  }
}
```

## オブジェクトの削除の許可(`DeleteRef`)

デフォルトの方法(削除を許可)で作成されたオブジェクトの場合,後で使用できる`DeleteRef`を生成できます.これにより,不要なものを削除し,ストレージの払い戻しを受けることができます.

削除不可能なオブジェクトに対して`DeleteRef`を作成することはできません.

```move filename="Example.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object::{Self, Object};

  /// Caller is not the owner of the object
  const E_NOT_OWNER: u64 = 1;

  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
  struct ObjectController has key {
    delete_ref: object::DeleteRef,
  }

  entry fun create_my_object(
    caller: &signer,
    _transferrable: bool,
    _controllable: bool
  ) {
    let caller_address = signer::address_of(caller);

    // Creates the object
    let constructor_ref = object::create_object(caller_address);

    // Retrieves a signer for the object
    let object_signer = object::generate_signer(&constructor_ref);

    // Creates and store the delete ref
    let delete_ref = object::generate_delete_ref(&constructor_ref);
    move_to(&object_signer, ObjectController {
      delete_ref
    });
    // ...
  }

  /// Now only let the owner delete the object
  entry fun delete(
    caller: &signer,
    object: Object<ObjectController>,
  ) acquires ObjectController {
    // Only let caller delete
    let caller_address = signer::address_of(caller);
    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);

    let object_address = object::object_address(&object);

    // Retrieve the delete ref, it is consumed so it must be extracted
    // from the resource
    let ObjectController {
      delete_ref
    } = move_from<ObjectController>(
      object_address
    );

    // Delete the object forever!
    object::delete(delete_ref);
  }
}
```

## オブジェクトを不変にする

オブジェクトは,関連するコントラクトを不変にし,オブジェクトを拡張または変更する機能を削除することで不変にできます.デフォルトでは,コントラクトは不変ではなく,オブジェクトは`ExtendRef`で拡張でき,コントラクトが許可する場合はリソースを変更できます.

## さらなる読み物

すべての可能な`Ref`のドキュメントは,[こちら](https://aptos.dev/reference/move?branch=mainnet\&page=aptos-framework/doc/object.md)の`0x1::object`のMoveリファレンスドキュメントで見つけることができます.

また,オブジェクトが構築された後の使用方法については[こちら](/ja/build/smart-contracts/object/using-objects)で確認できます.
