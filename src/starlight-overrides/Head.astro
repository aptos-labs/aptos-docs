---
import Default from "@astrojs/starlight/components/Head.astro";
import { ClientRouter } from "astro:transitions";
import { Schema } from "astro-seo-schema";
import { Font } from "astro:assets";
import globalCssUrl from "../styles/global.css?url";
import { SUPPORTED_LANGUAGES } from "~/config/i18n";
import { getImageUrl } from "~/lib/og-image/getImageUrl";

const entryData = Astro.locals.starlightRoute.entry.data || Astro.props.entry.data;
const ogImageUrl = await getImageUrl(new URL("/api/og-image.png", Astro.site), {
  title: entryData.title,
  siteTitle: Astro.locals.starlightRoute.siteTitle,
});

const { description, lang, lastUpdated, title } = Astro.locals.starlightRoute;

// Get non-English language codes
const nonEnglishLangCodes = SUPPORTED_LANGUAGES.filter(({ code }) => code !== "en").map(
  ({ code }) => code,
);

// Create a regex pattern for language path matching
const langPathRegex = new RegExp(`^\\/(${nonEnglishLangCodes.join("|")})\\/`);

// Function to generate URLs for other language versions
function getLanguageUrl(targetLang: string): string {
  const currentPath = Astro.url.pathname;
  const basePath = Astro.site?.href.replace(/\/$/, "") || "";

  // If we're already at the root and the target is English, just return the current URL
  if (targetLang === "en" && !currentPath.match(langPathRegex)) {
    return Astro.url.href;
  }

  // If we're in a language path and the target is English, remove the language prefix
  if (targetLang === "en" && currentPath.match(langPathRegex)) {
    return `${basePath}${currentPath.replace(langPathRegex, "")}`;
  }

  // If we're targeting a non-English language
  if (targetLang !== "en") {
    // If we're already in that language, return the current URL
    if (currentPath.startsWith(`/${targetLang}/`)) {
      return Astro.url.href;
    }

    // If we're in another language path, replace the language prefix
    if (currentPath.match(langPathRegex)) {
      return `${basePath}${currentPath.replace(langPathRegex, `/${targetLang}/`)}`;
    }

    // If we're at the root (English), add the language prefix
    return `${basePath}/${targetLang}${currentPath}`;
  }

  return Astro.url.href;
}

// Generate translation URLs for all languages except current
const translationUrls = SUPPORTED_LANGUAGES.filter(({ code }) => code !== lang).map(({ code }) => ({
  language: code,
  url: getLanguageUrl(code),
}));

// Determine if this is a translation (non-English) or original (English)
const isTranslation = lang !== "en";

// Generate organization name - keeping "Aptos Foundation" as the official entity name
const orgName = "Aptos Foundation";

// Generate keywords by language dynamically
const baseKeywords = ["Aptos", "blockchain", "web3"];
const keywordTranslations = {
  en: { "Move language": "Move language" },
  es: { "Move language": "Lenguaje Move" },
  zh: { "Move language": "Move 语言" },
  //ja: { "Move language": "Move言語" },
};

const keywords = Object.fromEntries(
  SUPPORTED_LANGUAGES.map(({ code }) => [
    code,
    [
      ...baseKeywords,
      keywordTranslations[code as keyof typeof keywordTranslations]?.["Move language"] ||
        keywordTranslations.en["Move language"],
    ],
  ]),
);

const lastUpdatedDate = lastUpdated ? lastUpdated.toISOString() : new Date().toISOString();

// Generate BreadcrumbList structured data from URL path segments
const basePath = Astro.site?.href.replace(/\/$/, "") || "";
const pathWithoutLocale = Astro.url.pathname.replace(langPathRegex, "/");
const pathSegments = pathWithoutLocale.split("/").filter(Boolean);

function formatSegmentName(segment: string): string {
  return segment
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

// Translated "Home" label for breadcrumbs
const homeLabelByLang: Record<string, string> = {
  zh: "首页",
  es: "Inicio",
};
const homeLabel = homeLabelByLang[lang] || "Home";

// Build breadcrumb items: Home + each path segment
const localePrefix = lang !== "en" ? `/${lang}` : "";

function buildBreadcrumbUrl(index: number): string {
  const segments = [localePrefix.replace(/^\//, ""), ...pathSegments.slice(0, index + 1)].filter(
    Boolean,
  );
  return `${basePath}/${segments.join("/")}`;
}

const breadcrumbItems = [
  { name: homeLabel, url: `${basePath}${localePrefix || "/"}` },
  ...pathSegments.map((segment, index) => ({
    name: formatSegmentName(segment),
    url: buildBreadcrumbUrl(index),
  })),
];
---

{/* Critical font preload with high priority */}
<Font cssVariable="--font-atkinson-hyperlegible-next" preload />

{/* Resource hints for external services */}
<link rel="preconnect" href="https://api.testnet.staging.aptoslabs.com" crossorigin="anonymous" />
<link rel="dns-prefetch" href="https://api.testnet.staging.aptoslabs.com" />

{/* Algolia search - preconnect for faster search initialization */}
<link rel="preconnect" href="https://algolia.net" crossorigin="anonymous" />
<link rel="preconnect" href="https://algolianet.com" crossorigin="anonymous" />

{/* Google Tag Manager - preconnect for analytics (loaded via partytown) */}
<link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous" />
<link rel="dns-prefetch" href="https://www.googletagmanager.com" />

{/* Critical CSS with high fetch priority */}
<link rel="preload" href={globalCssUrl} as="style" fetchpriority="high" />

{/* hreflang x-default: tells search engines which URL to serve when no locale matches */}
<link rel="alternate" hreflang="x-default" href={getLanguageUrl("en")} />

<Schema
  item={{
    "@context": "https://schema.org",
    "@type": "TechArticle",
    headline: title as string,
    description: description as string,
    inLanguage: lang,
    url: Astro.url.href,

    // If this is a translation, link to the English original
    ...(isTranslation && {
      translationOfWork: {
        "@type": "TechArticle",
        url: getLanguageUrl("en"),
      },
    }),

    // If this is the English original, link to all translations
    ...(!isTranslation &&
      translationUrls.length > 0 && {
        workTranslation: translationUrls.map((t) => ({
          "@type": "TechArticle",
          url: t.url,
        })),
      }),

    keywords: keywords[lang as keyof typeof keywords] || keywords.en,

    sameAs: [
      "https://aptosnetwork.com/",
      "https://discord.com/invite/aptosnetwork",
      "https://github.com/aptos-foundation",
      "https://www.linkedin.com/company/aptos-foundation/",
      "https://www.reddit.com/r/Aptos/",
      "https://t.me/aptos",
      "https://twitter.com/aptos",
    ],
    audience: {
      "@type": "Audience",
      audienceType: "Developers",
    },
    mainEntityOfPage: {
      "@type": "WebPage",
      "@id": Astro.url.href,
    },
    author: {
      "@type": "Organization",
      name: orgName,
      url: Astro.site?.href || "",
      logo: {
        "@type": "ImageObject",
        url: `${Astro.site?.href || ""}schema-logo.svg`,
      },
    },
    publisher: {
      "@type": "Organization",
      name: orgName,
      url: Astro.site?.href || "",
      logo: {
        "@type": "ImageObject",
        url: `${Astro.site?.href || ""}schema-logo.svg`,
      },
    },
    dateModified: lastUpdatedDate,
    // datePublished: entryData.publishDate ? new Date(entryData.publishDate).toISOString() : undefined,
  }}
/>

{/* BreadcrumbList structured data for page hierarchy */}
{
  breadcrumbItems.length > 1 && (
    <Schema
      item={{
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        itemListElement: breadcrumbItems.map((crumb, index) => ({
          "@type": "ListItem",
          position: index + 1,
          name: crumb.name,
          item: crumb.url,
        })),
      }}
    />
  )
}

<Default {...Astro.props}><slot /></Default>

<!-- <meta property="article:published_time" content={entryData.publishDate} /> -->
<meta property="article:modified_time" content={lastUpdatedDate} />
<!-- Algolia docsearch language facet -->
<meta name="docsearch:language" content={lang} />
<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content={Astro.request.url} />
<meta property="og:title" content={title as string} />
{
  entryData.description && (
    <meta property="og:description" content={entryData.description as string} />
  )
}
{
  ogImageUrl && (
    <>
      {/* Open Graph image */}
      <meta property="og:image" content={ogImageUrl} />

      {/* Twitter card */}
      <meta name="twitter:image" content={ogImageUrl} />
      <meta name="twitter:card" content="summary_large_image" />
    </>
  )
}
<meta name="twitter:title" content={entryData.title as string} />
{
  entryData.description && (
    <meta name="twitter:description" content={entryData.description as string} />
  )
}

{/* View Transitions for SPA-like navigation */}
<style is:global>
  ::view-transition-old(root),
  ::view-transition-new(root) {
    animation-duration: 0.1s;
    animation-timing-function: cubic-bezier(0.4, 0, 0.1, 1);
  }
</style>
<ClientRouter />
